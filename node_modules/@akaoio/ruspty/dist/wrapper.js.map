{"version":3,"sources":["../wrapper.ts"],"sourcesContent":["import type { Readable, Writable } from 'node:stream';\nimport { ReadStream } from 'node:tty';\nimport {\n  Pty as RawPty,\n  type Size,\n  setCloseOnExec as rawSetCloseOnExec,\n  getCloseOnExec as rawGetCloseOnExec,\n  ptyResize,\n  MAX_U16_VALUE,\n  MIN_U16_VALUE,\n} from './index.js';\nimport {\n  type PtyOptions,\n  Operation,\n  type SandboxRule,\n  type SandboxOptions,\n} from './index.js';\n\nexport { Operation, type SandboxRule, type SandboxOptions, type PtyOptions };\n\ntype ExitResult = {\n  error: NodeJS.ErrnoException | null;\n  code: number;\n};\n\n/**\n * A very thin wrapper around PTYs and processes.\n *\n * @example\n * const { Pty } = require('@replit/ruspty');\n *\n * const pty = new Pty({\n *   command: '/bin/sh',\n *   args: [],\n *   envs: ENV,\n *   dir: CWD,\n *   size: { rows: 24, cols: 80 },\n *   onExit: (...result) => {\n *     // TODO: Handle process exit.\n *   },\n * });\n *\n * const read = pty.read;\n * const write = pty.write;\n *\n * read.on('data', (chunk) => {\n *   // TODO: Handle data.\n * });\n * write.write('echo hello\\n');\n */\nexport class Pty {\n  #pty: RawPty;\n  #fd: number;\n\n  #handledClose: boolean = false;\n  #fdClosed: boolean = false;\n\n  #socket: ReadStream;\n\n  get read(): Readable {\n    return this.#socket;\n  }\n\n  get write(): Writable {\n    return this.#socket;\n  }\n\n  constructor(options: PtyOptions) {\n    const realExit = options.onExit;\n\n    let markExited!: (value: ExitResult) => void;\n    let exitResult: Promise<ExitResult> = new Promise((resolve) => {\n      markExited = resolve;\n    });\n\n    let markReadFinished!: () => void;\n    let readFinished = new Promise<void>((resolve) => {\n      markReadFinished = resolve;\n    });\n    const mockedExit = (error: NodeJS.ErrnoException | null, code: number) => {\n      markExited({ error, code });\n    };\n\n    // when pty exits, we should wait until the fd actually ends (end OR error)\n    // before closing the pty\n    // we use a mocked exit function to capture the exit result\n    // and then call the real exit function after the fd is fully read\n    this.#pty = new RawPty({ ...options, onExit: mockedExit });\n    // Transfer ownership of the FD to us.\n    this.#fd = this.#pty.takeFd();\n\n    this.#socket = new ReadStream(this.#fd);\n\n    // catch end events\n    const handleClose = async () => {\n      if (this.#fdClosed) {\n        return;\n      }\n\n      this.#fdClosed = true;\n\n      // must wait for fd close and exit result before calling real exit\n      await readFinished;\n      const result = await exitResult;\n      realExit(result.error, result.code);\n    };\n\n    this.read.once('end', markReadFinished);\n    this.read.once('close', handleClose);\n\n    // PTYs signal their done-ness with an EIO error. we therefore need to filter them out (as well as\n    // cleaning up other spurious errors) so that the user doesn't need to handle them and be in\n    // blissful peace.\n    const handleError = (err: NodeJS.ErrnoException) => {\n      if (err.code) {\n        const code = err.code;\n        if (code === 'EINTR' || code === 'EAGAIN') {\n          // these two are expected. EINTR happens when the kernel restarts a `read(2)`/`write(2)`\n          // syscall due to it being interrupted by another syscall, and EAGAIN happens when there\n          // is no more data to be read by the fd.\n          return;\n        } else if (code.indexOf('EIO') !== -1) {\n          // EIO only happens when the child dies. It is therefore our only true signal that there\n          // is nothing left to read and we can start tearing things down. If we hadn't received an\n          // error so far, we are considered to be in good standing.\n          this.read.off('error', handleError);\n          // emit 'end' to signal no more data\n          // this will trigger our 'end' handler which marks readFinished\n          this.read.emit('end');\n          return;\n        }\n      }\n\n      // if we haven't handled the error by now, we should throw it\n      throw err;\n    };\n\n    this.read.on('error', handleError);\n  }\n\n  close() {\n    this.#handledClose = true;\n\n    // end instead of destroy so that the user can read the last bits of data\n    // and allow graceful close event to mark the fd as ended\n    this.#socket.end();\n  }\n\n  resize(size: Size) {\n    if (this.#handledClose || this.#fdClosed) {\n      return;\n    }\n\n    if (\n      size.cols < MIN_U16_VALUE ||\n      size.cols > MAX_U16_VALUE ||\n      size.rows < MIN_U16_VALUE ||\n      size.rows > MAX_U16_VALUE\n    ) {\n      throw new RangeError(\n        `Size (${size.rows}x${size.cols}) out of range: must be between ${MIN_U16_VALUE} and ${MAX_U16_VALUE}`,\n      );\n    }\n\n    try {\n      ptyResize(this.#fd, size);\n    } catch (e: unknown) {\n      // napi-rs only throws strings so we must string match here\n      // https://docs.rs/napi/latest/napi/struct.Error.html#method.new\n      if (\n        e instanceof Error &&\n        (e.message.indexOf('os error 9') !== -1 || // EBADF\n          e.message.indexOf('os error 25') !== -1)\n      ) {\n        // ENOTTY\n        // error 9 is EBADF (bad file descriptor)\n        // error 25 is ENOTTY (inappropriate ioctl for device)\n        // These can happen if the PTY has already exited or wasn't a terminal device\n        // In that case, we just ignore the error.\n        return;\n      }\n\n      // otherwise, rethrow\n      throw e;\n    }\n  }\n\n  get pid() {\n    return this.#pty.pid;\n  }\n}\n\n/**\n * Set the close-on-exec flag on a file descriptor. This is `fcntl(fd, F_SETFD, FD_CLOEXEC)` under\n * the covers.\n */\nexport const setCloseOnExec = rawSetCloseOnExec;\n\n/**\n * Get the close-on-exec flag on a file descriptor. This is `fcntl(fd, F_GETFD) & FD_CLOEXEC ==\n * FD_CLOEXEC` under the covers.\n */\nexport const getCloseOnExec = rawGetCloseOnExec;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAA2B;AAC3B,mBAQO;AACP,IAAAA,gBAKO;AAkCA,IAAM,MAAN,MAAU;AAAA,EACf;AAAA,EACA;AAAA,EAEA,gBAAyB;AAAA,EACzB,YAAqB;AAAA,EAErB;AAAA,EAEA,IAAI,OAAiB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,QAAkB;AACpB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,YAAY,SAAqB;AAC/B,UAAM,WAAW,QAAQ;AAEzB,QAAI;AACJ,QAAI,aAAkC,IAAI,QAAQ,CAAC,YAAY;AAC7D,mBAAa;AAAA,IACf,CAAC;AAED,QAAI;AACJ,QAAI,eAAe,IAAI,QAAc,CAAC,YAAY;AAChD,yBAAmB;AAAA,IACrB,CAAC;AACD,UAAM,aAAa,CAAC,OAAqC,SAAiB;AACxE,iBAAW,EAAE,OAAO,KAAK,CAAC;AAAA,IAC5B;AAMA,SAAK,OAAO,IAAI,aAAAC,IAAO,EAAE,GAAG,SAAS,QAAQ,WAAW,CAAC;AAEzD,SAAK,MAAM,KAAK,KAAK,OAAO;AAE5B,SAAK,UAAU,IAAI,2BAAW,KAAK,GAAG;AAGtC,UAAM,cAAc,YAAY;AAC9B,UAAI,KAAK,WAAW;AAClB;AAAA,MACF;AAEA,WAAK,YAAY;AAGjB,YAAM;AACN,YAAM,SAAS,MAAM;AACrB,eAAS,OAAO,OAAO,OAAO,IAAI;AAAA,IACpC;AAEA,SAAK,KAAK,KAAK,OAAO,gBAAgB;AACtC,SAAK,KAAK,KAAK,SAAS,WAAW;AAKnC,UAAM,cAAc,CAAC,QAA+B;AAClD,UAAI,IAAI,MAAM;AACZ,cAAM,OAAO,IAAI;AACjB,YAAI,SAAS,WAAW,SAAS,UAAU;AAIzC;AAAA,QACF,WAAW,KAAK,QAAQ,KAAK,MAAM,IAAI;AAIrC,eAAK,KAAK,IAAI,SAAS,WAAW;AAGlC,eAAK,KAAK,KAAK,KAAK;AACpB;AAAA,QACF;AAAA,MACF;AAGA,YAAM;AAAA,IACR;AAEA,SAAK,KAAK,GAAG,SAAS,WAAW;AAAA,EACnC;AAAA,EAEA,QAAQ;AACN,SAAK,gBAAgB;AAIrB,SAAK,QAAQ,IAAI;AAAA,EACnB;AAAA,EAEA,OAAO,MAAY;AACjB,QAAI,KAAK,iBAAiB,KAAK,WAAW;AACxC;AAAA,IACF;AAEA,QACE,KAAK,OAAO,8BACZ,KAAK,OAAO,8BACZ,KAAK,OAAO,8BACZ,KAAK,OAAO,4BACZ;AACA,YAAM,IAAI;AAAA,QACR,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,mCAAmC,0BAAa,QAAQ,0BAAa;AAAA,MACtG;AAAA,IACF;AAEA,QAAI;AACF,kCAAU,KAAK,KAAK,IAAI;AAAA,IAC1B,SAAS,GAAY;AAGnB,UACE,aAAa,UACZ,EAAE,QAAQ,QAAQ,YAAY,MAAM;AAAA,MACnC,EAAE,QAAQ,QAAQ,aAAa,MAAM,KACvC;AAMA;AAAA,MACF;AAGA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,IAAI,MAAM;AACR,WAAO,KAAK,KAAK;AAAA,EACnB;AACF;AAMO,IAAM,iBAAiB,aAAAC;AAMvB,IAAM,iBAAiB,aAAAC;","names":["import_index","RawPty","rawSetCloseOnExec","rawGetCloseOnExec"]}