// src/Replay/constructor.ts
function constructor() {
  this.events = [];
  this.startTime = Date.now();
  this.data = {
    version: "1.0.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    duration: 0,
    events: [],
    metadata: {
      cols: 80,
      rows: 24,
      command: "",
      args: [],
      env: {}
    }
  };
}

// src/Replay/record.ts
function record(event) {
  const timestampedEvent = {
    ...event,
    timestamp: Date.now() - this.startTime
  };
  this.events.push(timestampedEvent);
}

// src/Replay/save.ts
import fs from "fs";
import path from "path";
function save(filePath) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  this.data.events = this.events;
  this.data.duration = Date.now() - this.startTime;
  const json = JSON.stringify(this.data, null, 2);
  fs.writeFileSync(filePath, json);
  return filePath;
}

// src/Replay/load.ts
import fs2 from "fs";
function load(filePath) {
  const json = fs2.readFileSync(filePath, "utf-8");
  this.data = JSON.parse(json);
  this.events = this.data.events || [];
  if (!this.data.version || !this.data.events) {
    throw new Error("Invalid replay file format");
  }
}

// src/utils/colors.ts
var colors = {
  reset: "\x1B[0m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  gray: "\x1B[90m",
  bgRed: "\x1B[41m",
  bgGreen: "\x1B[42m",
  bgYellow: "\x1B[43m",
  bgBlue: "\x1B[44m",
  bold: "\x1B[1m",
  dim: "\x1B[2m"
};
var createColorFunction = (colorCode) => {
  const fn = (text) => `${colorCode}${text}${colors.reset}`;
  fn.bold = (text) => `${colorCode}${colors.bold}${text}${colors.reset}`;
  fn.dim = (text) => `${colorCode}${colors.dim}${text}${colors.reset}`;
  return fn;
};
var color = {
  red: createColorFunction(colors.red),
  green: createColorFunction(colors.green),
  yellow: createColorFunction(colors.yellow),
  blue: createColorFunction(colors.blue),
  magenta: createColorFunction(colors.magenta),
  cyan: createColorFunction(colors.cyan),
  gray: createColorFunction(colors.gray),
  bold: (text) => `${colors.bold}${text}${colors.reset}`,
  dim: (text) => `${colors.dim}${text}${colors.reset}`,
  bgRed: (text) => `${colors.bgRed}${text}${colors.reset}`,
  bgGreen: (text) => `${colors.bgGreen}${text}${colors.reset}`,
  bgYellow: (text) => `${colors.bgYellow}${text}${colors.reset}`,
  bgBlue: (text) => `${colors.bgBlue}${text}${colors.reset}`,
  white: (text) => text
  // White is default
};
var chalk = color;
try {
  const loadChalk = async () => {
    try {
      const chalkModule = await import("./source-NRTP7HXM.js");
      chalk = chalkModule.default || chalkModule;
    } catch {
      chalk = color;
    }
  };
  loadChalk().catch(() => {
  });
} catch {
  chalk = color;
}

// src/Replay/PlaybackEngine.ts
var PlaybackEngine = class {
  events;
  duration;
  state;
  options;
  animationFrame = null;
  lastFrameTime = 0;
  constructor(events, duration, options = {}) {
    this.events = events;
    this.duration = duration;
    this.options = {
      speed: 1,
      verbose: false,
      ...options
    };
    this.state = {
      isPlaying: false,
      isPaused: false,
      speed: this.options.speed || 1,
      currentEventIndex: 0,
      currentTime: 0,
      startTime: 0,
      lastPlayTime: 0
    };
  }
  // Core playback controls
  play() {
    if (this.state.isPlaying) return;
    this.state.isPlaying = true;
    this.state.isPaused = false;
    this.state.startTime = Date.now() - this.state.currentTime;
    this.state.lastPlayTime = Date.now();
    this.notifyStateChange();
    this.scheduleNextFrame();
  }
  pause() {
    if (!this.state.isPlaying) return;
    this.state.isPlaying = false;
    this.state.isPaused = true;
    if (this.animationFrame) {
      if (typeof cancelAnimationFrame !== "undefined") {
        cancelAnimationFrame(this.animationFrame);
      } else if (this.animationFrame) {
        clearTimeout(this.animationFrame);
      }
      this.animationFrame = null;
    }
    this.notifyStateChange();
  }
  stop() {
    this.pause();
    this.state.currentEventIndex = 0;
    this.state.currentTime = 0;
    this.state.isPaused = false;
    this.notifyStateChange();
    this.notifyProgress();
  }
  restart() {
    this.stop();
    this.play();
  }
  // Speed control
  setSpeed(speed) {
    this.state.speed = Math.max(0, Math.min(50, speed));
    this.notifyStateChange();
  }
  getSpeed() {
    return this.state.speed;
  }
  // Seeking controls
  seek(timeMs) {
    const targetTime = Math.max(0, Math.min(this.duration, timeMs));
    this.state.currentTime = targetTime;
    this.state.currentEventIndex = 0;
    for (let i = 0; i < this.events.length; i++) {
      if (this.events[i].timestamp > targetTime) {
        break;
      }
      this.state.currentEventIndex = i;
    }
    for (let i = 0; i < this.state.currentEventIndex; i++) {
      this.notifyEvent(this.events[i]);
    }
    this.notifyStateChange();
    this.notifyProgress();
  }
  seekToPercent(percent) {
    const targetTime = percent / 100 * this.duration;
    this.seek(targetTime);
  }
  skipForward(ms = 1e3) {
    this.seek(this.state.currentTime + ms);
  }
  skipBackward(ms = 1e3) {
    this.seek(this.state.currentTime - ms);
  }
  jumpToStart() {
    this.seek(0);
  }
  jumpToEnd() {
    this.seek(this.duration);
    this.state.currentEventIndex = this.events.length;
  }
  // State getters
  getState() {
    return { ...this.state };
  }
  getCurrentTime() {
    return this.state.currentTime;
  }
  getDuration() {
    return this.duration;
  }
  getProgress() {
    return this.duration > 0 ? this.state.currentTime / this.duration * 100 : 0;
  }
  getCurrentEventIndex() {
    return this.state.currentEventIndex;
  }
  getTotalEvents() {
    return this.events.length;
  }
  isPlaying() {
    return this.state.isPlaying;
  }
  isPaused() {
    return this.state.isPaused;
  }
  // Private methods for animation and event processing
  scheduleNextFrame() {
    if (!this.state.isPlaying) return;
    const now = Date.now();
    const deltaTime = now - this.state.lastPlayTime;
    this.state.lastPlayTime = now;
    if (this.state.speed > 0) {
      this.state.currentTime += deltaTime * this.state.speed;
      while (this.state.currentEventIndex < this.events.length) {
        const event = this.events[this.state.currentEventIndex];
        if (event.timestamp > this.state.currentTime) {
          break;
        }
        this.notifyEvent(event);
        this.state.currentEventIndex++;
      }
      this.notifyProgress();
    }
    if (this.state.currentTime >= this.duration || this.state.currentEventIndex >= this.events.length) {
      this.state.isPlaying = false;
      this.state.currentTime = this.duration;
      this.notifyStateChange();
      this.notifyProgress();
      return;
    }
    if (typeof requestAnimationFrame !== "undefined") {
      this.animationFrame = requestAnimationFrame(() => this.scheduleNextFrame());
    } else {
      this.animationFrame = setTimeout(() => this.scheduleNextFrame(), 16);
    }
  }
  notifyEvent(event) {
    if (this.options.onEvent) {
      this.options.onEvent(event, this.getState());
    }
  }
  notifyStateChange() {
    if (this.options.onStateChange) {
      this.options.onStateChange(this.getState());
    }
  }
  notifyProgress() {
    if (this.options.onProgress) {
      this.options.onProgress(this.getProgress(), this.getState());
    }
  }
  // Cleanup
  destroy() {
    this.stop();
    this.options = {};
  }
};
function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1e3);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, "0")}`;
}
function getEventDescription(event) {
  switch (event.type) {
    case "spawn":
      return `SPAWN ${event.data.command} ${event.data.args?.join(" ") || ""}`;
    case "output":
      return `OUTPUT (${event.data.length} bytes)`;
    case "input":
      return `INPUT ${JSON.stringify(event.data)}`;
    case "key":
      return `KEY ${event.data}`;
    case "resize":
      return `RESIZE ${event.data.cols}x${event.data.rows}`;
    case "screenshot":
      return `SCREENSHOT ${event.data.name}`;
    case "expect":
      return `EXPECT ${event.data.pattern || event.data}`;
    case "exit":
      return `EXIT code ${event.data}`;
    default:
      return event.type.toUpperCase();
  }
}

// src/Replay/play.ts
async function play(options = {}) {
  const replayData = this.data;
  const events = this.events;
  const totalDuration = replayData.duration;
  const totalEvents = events.length;
  const engine = new PlaybackEngine(events, totalDuration, {
    speed: options.speed || 1,
    verbose: options.verbose,
    onEvent: (event, state) => executeEvent(event, state),
    onStateChange: (state) => updateStatusLine(state),
    onProgress: (progress, state) => updateStatusLine(state)
  });
  let replayOutput = "";
  const replayPty = {
    write: (data) => {
    },
    resize: (cols, rows) => {
    },
    kill: () => {
    },
    killed: false
  };
  console.clear();
  showHeader(replayData, totalDuration, totalEvents);
  showControls();
  updateStatusLine(engine.getState());
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();
  const handleKeypress = (chunk) => {
    const key = chunk.toString();
    switch (key) {
      case " ":
        if (engine.isPlaying()) {
          engine.pause();
        } else {
          engine.play();
        }
        break;
      case "s":
        engine.stop();
        clearTerminal();
        break;
      case "r":
        engine.restart();
        clearTerminal();
        break;
      case "e":
        engine.jumpToEnd();
        break;
      case "+":
      // Speed up
      case "=":
        engine.setSpeed(Math.min(50, engine.getSpeed() * 2));
        break;
      case "-":
        engine.setSpeed(Math.max(0.1, engine.getSpeed() / 2));
        break;
      case "0":
        engine.setSpeed(0);
        engine.pause();
        break;
      case "1":
        engine.setSpeed(1);
        break;
      case "2":
        engine.setSpeed(2);
        break;
      case "4":
        engine.setSpeed(4);
        break;
      case "\x1B":
      // Escape - quit
      case "q":
        cleanup2();
        process.exit(0);
        break;
      case "\x1B[C":
        engine.skipForward(1e3);
        break;
      case "\x1B[D":
        engine.skipBackward(1e3);
        break;
    }
  };
  process.stdin.on("data", handleKeypress);
  function executeEvent(event, state) {
    const eventDisplay = getEventDescription(event);
    process.stdout.write("\x1B[s");
    process.stdout.write("\x1B[H");
    process.stdout.write("\x1B[12;1H");
    process.stdout.write("\x1B[K");
    process.stdout.write(`\u{1F4FA} Event: ${color.cyan(eventDisplay)}`);
    process.stdout.write("\x1B[u");
    switch (event.type) {
      case "output":
        process.stdout.write("\x1B[14;1H");
        process.stdout.write(event.data);
        break;
      case "input":
        replayOutput += event.data;
        break;
      case "resize":
        process.stdout.write("\x1B[s");
        process.stdout.write("\x1B[12;1H");
        process.stdout.write("\x1B[K");
        process.stdout.write(`\u{1F4D0} Terminal resized to ${event.data.cols}x${event.data.rows}`);
        process.stdout.write("\x1B[u");
        break;
      case "key":
        process.stdout.write("\x1B[s");
        process.stdout.write("\x1B[13;1H");
        process.stdout.write("\x1B[K");
        process.stdout.write(`\u2328\uFE0F  Key pressed: ${color.green(event.data)}`);
        process.stdout.write("\x1B[u");
        break;
    }
  }
  function updateStatusLine(state) {
    const progress = engine.getProgress();
    const progressBar = createProgressBar(progress);
    const currentTimeStr = formatTime(engine.getCurrentTime());
    const totalTimeStr = formatTime(totalDuration);
    const statusIcon = state.isPlaying ? "\u25B6\uFE0F" : state.isPaused ? "\u23F8\uFE0F" : "\u23F9\uFE0F";
    const speedDisplay = state.speed === 0 ? "\u23F8\uFE0F 0\xD7" : `\u{1F680} ${state.speed}\xD7`;
    process.stdout.write("\x1B[s");
    process.stdout.write("\x1B[10;1H");
    process.stdout.write("\x1B[K");
    process.stdout.write(
      `${statusIcon} ${progressBar} ${color.yellow(currentTimeStr)}/${color.yellow(totalTimeStr)} ${speedDisplay} [${state.currentEventIndex}/${totalEvents}]`
    );
    process.stdout.write("\x1B[u");
  }
  function clearTerminal() {
    console.clear();
    showHeader(replayData, totalDuration, totalEvents);
    showControls();
    updateStatusLine(engine.getState());
  }
  function cleanup2() {
    engine.destroy();
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(false);
    }
    process.stdin.pause();
    console.clear();
    console.log(color.green("Battle Replay Player - Goodbye!"));
  }
  process.on("SIGINT", cleanup2);
  process.on("SIGTERM", cleanup2);
  if (!options.manual) {
    engine.play();
  }
  return new Promise((resolve) => {
    const checkComplete = () => {
      const state = engine.getState();
      if (!state.isPlaying && state.currentEventIndex >= totalEvents) {
        cleanup2();
        resolve();
      } else {
        setTimeout(checkComplete, 100);
      }
    };
    if (options.manual) {
    } else {
      checkComplete();
    }
  });
}
function showHeader(data, duration, totalEvents) {
  console.log(color.blue.bold("\u{1F3AC} Battle Replay Player - YouTube Style Controls"));
  console.log(color.gray(`\u{1F4FC} File: ${data.version} | \u{1F4C5} ${data.timestamp}`));
  console.log(color.gray(`\u23F1\uFE0F  Duration: ${formatTime(duration)} | \u{1F3AF} Events: ${totalEvents}`));
  console.log("");
}
function showControls() {
  console.log(color.cyan.bold("\u{1F3AE} CONTROLS:"));
  console.log(color.white("  SPACE") + color.gray(" - Play/Pause  ") + color.white("S") + color.gray(" - Stop  ") + color.white("R") + color.gray(" - Restart  ") + color.white("E") + color.gray(" - End"));
  console.log(color.white("  +/-  ") + color.gray(" - Speed Up/Down  ") + color.white("0-4") + color.gray(" - Speed Presets  ") + color.white("\u2190\u2192") + color.gray(" - Skip"));
  console.log(color.white("  Q/ESC") + color.gray(" - Quit"));
  console.log("");
}
function createProgressBar(percent, width = 40) {
  const filled = Math.round(percent / 100 * width);
  const empty = width - filled;
  const filledBar = "\u2588".repeat(filled);
  const emptyBar = "\u2591".repeat(empty);
  return color.red(filledBar) + color.gray(emptyBar) + ` ${percent.toFixed(1)}%`;
}

// src/Replay/getPlaybackEngineSource.ts
function getPlaybackEngineSource() {
  return `
// Unified PlaybackEngine for consistent replay behavior
class PlaybackEngine {
    constructor(events, duration, options = {}) {
        this.events = events;
        this.duration = duration;
        this.options = {
            speed: 1.0,
            verbose: false,
            ...options
        };
        
        this.state = {
            isPlaying: false,
            isPaused: false,
            speed: this.options.speed || 1.0,
            currentEventIndex: 0,
            currentTime: 0,
            startTime: 0,
            lastPlayTime: 0
        };
        
        this.animationFrame = null;
        this.lastFrameTime = 0;
    }

    // Core playback controls
    play() {
        if (this.state.isPlaying) return;
        
        this.state.isPlaying = true;
        this.state.isPaused = false;
        this.state.startTime = Date.now() - this.state.currentTime;
        this.state.lastPlayTime = Date.now();
        
        this.notifyStateChange();
        this.scheduleNextFrame();
    }

    pause() {
        if (!this.state.isPlaying) return;
        
        this.state.isPlaying = false;
        this.state.isPaused = true;
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
        
        this.notifyStateChange();
    }

    stop() {
        this.pause();
        this.state.currentEventIndex = 0;
        this.state.currentTime = 0;
        this.state.isPaused = false;
        this.notifyStateChange();
        this.notifyProgress();
    }

    restart() {
        this.stop();
        this.play();
    }

    // Speed control
    setSpeed(speed) {
        this.state.speed = Math.max(0, Math.min(50, speed));
        this.notifyStateChange();
    }

    getSpeed() {
        return this.state.speed;
    }

    // Seeking controls
    seek(timeMs) {
        const targetTime = Math.max(0, Math.min(this.duration, timeMs));
        this.state.currentTime = targetTime;
        
        // Find the appropriate event index
        this.state.currentEventIndex = 0;
        for (let i = 0; i < this.events.length; i++) {
            if (this.events[i].timestamp > targetTime) {
                break;
            }
            this.state.currentEventIndex = i;
        }
        
        // Process all events up to this point
        for (let i = 0; i < this.state.currentEventIndex; i++) {
            this.notifyEvent(this.events[i]);
        }
        
        this.notifyStateChange();
        this.notifyProgress();
    }

    seekToPercent(percent) {
        const targetTime = (percent / 100) * this.duration;
        this.seek(targetTime);
    }

    skipForward(ms = 1000) {
        this.seek(this.state.currentTime + ms);
    }

    skipBackward(ms = 1000) {
        this.seek(this.state.currentTime - ms);
    }

    jumpToStart() {
        this.seek(0);
    }

    jumpToEnd() {
        this.seek(this.duration);
        this.state.currentEventIndex = this.events.length;
    }

    // State getters
    getState() {
        return { ...this.state };
    }

    getCurrentTime() {
        return this.state.currentTime;
    }

    getDuration() {
        return this.duration;
    }

    getProgress() {
        return this.duration > 0 ? (this.state.currentTime / this.duration) * 100 : 0;
    }

    getCurrentEventIndex() {
        return this.state.currentEventIndex;
    }

    getTotalEvents() {
        return this.events.length;
    }

    isPlaying() {
        return this.state.isPlaying;
    }

    isPaused() {
        return this.state.isPaused;
    }

    // Private methods for animation and event processing
    scheduleNextFrame() {
        if (!this.state.isPlaying) return;
        
        const now = Date.now();
        const deltaTime = now - this.state.lastPlayTime;
        this.state.lastPlayTime = now;
        
        // Update current time based on speed
        if (this.state.speed > 0) {
            this.state.currentTime += deltaTime * this.state.speed;
            
            // Process events up to current time
            while (this.state.currentEventIndex < this.events.length) {
                const event = this.events[this.state.currentEventIndex];
                if (event.timestamp > this.state.currentTime) {
                    break;
                }
                
                this.notifyEvent(event);
                this.state.currentEventIndex++;
            }
            
            this.notifyProgress();
        }
        
        // Check if playback is complete
        if (this.state.currentTime >= this.duration || 
            this.state.currentEventIndex >= this.events.length) {
            this.state.isPlaying = false;
            this.state.currentTime = this.duration;
            this.notifyStateChange();
            this.notifyProgress();
            return;
        }
        
        // Schedule next frame
        this.animationFrame = requestAnimationFrame(() => this.scheduleNextFrame());
    }

    notifyEvent(event) {
        if (this.options.onEvent) {
            this.options.onEvent(event, this.getState());
        }
    }

    notifyStateChange() {
        if (this.options.onStateChange) {
            this.options.onStateChange(this.getState());
        }
    }

    notifyProgress() {
        if (this.options.onProgress) {
            this.options.onProgress(this.getProgress(), this.getState());
        }
    }

    // Cleanup
    destroy() {
        this.stop();
        this.options = {};
    }
}
`;
}

// src/Replay/export.ts
function exportReplay(format) {
  if (format === "json") {
    return JSON.stringify(this.data, null, 2);
  }
  if (format === "html") {
    return `<!DOCTYPE html>
<html>
<head>
    <title>Battle Replay - ${this.data.timestamp}</title>
    <style>
        body {
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Cascadia Code', 'Courier New', monospace;
            padding: 20px;
            margin: 0;
        }
        
        .header {
            margin-bottom: 20px;
            padding: 15px;
            background: #2d2d30;
            border-radius: 8px;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            color: #007acc;
        }
        
        .metadata {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #cccccc;
        }
        
        #terminal {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            min-height: 400px;
            max-height: 600px;
            white-space: pre-wrap;
            overflow-y: auto;
            font-family: 'Cascadia Code', 'SF Mono', 'Monaco', 'Inconsolata', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid #3c3c3c;
        }
        
        .controls-container {
            background: #2d2d30;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .main-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            min-width: 60px;
        }
        
        .control-btn:hover {
            background: #005a9e;
        }
        
        .control-btn:active {
            background: #004578;
        }
        
        .control-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .secondary-btn {
            background: #6c757d;
            padding: 8px 12px;
            font-size: 12px;
        }
        
        .secondary-btn:hover {
            background: #545b62;
        }
        
        .progress-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .progress-bar {
            flex: 1;
            height: 8px;
            background: #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }
        
        .progress-fill {
            height: 100%;
            background: #007acc;
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: #007acc;
            border-radius: 50%;
            cursor: grab;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .progress-handle:active {
            cursor: grabbing;
        }
        
        .time-display {
            font-family: 'Cascadia Code', monospace;
            font-size: 14px;
            color: #cccccc;
            min-width: 100px;
        }
        
        .speed-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .speed-preset {
            background: #555;
            border: 1px solid #666;
            color: #ccc;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .speed-preset:hover {
            background: #666;
        }
        
        .speed-preset.active {
            background: #007acc;
            border-color: #007acc;
            color: white;
        }
        
        .speed-input-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #speedInput {
            width: 60px;
            padding: 5px;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 3px;
            color: #d4d4d4;
            font-size: 12px;
        }
        
        .event-log {
            background: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            font-family: 'Cascadia Code', monospace;
        }
        
        .event {
            padding: 2px 0;
            border-bottom: 1px solid #3c3c3c;
        }
        
        .event-spawn { color: #dcdcaa; }
        .event-output { color: #9cdcfe; }
        .event-input { color: #ce9178; }
        .event-key { color: #b5cea8; }
        .event-resize { color: #c586c0; }
        .event-screenshot { color: #608b4e; }
        .event-expect { color: #d7ba7d; }
        .event-exit { color: #f48771; }
        
        .status-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #555;
        }
        
        .status-dot.playing { background: #4ec9b0; animation: pulse 1s infinite; }
        .status-dot.paused { background: #ffcc00; }
        .status-dot.stopped { background: #f48771; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #eventCounter {
            margin-left: auto;
            color: #808080;
        }
        
        /* Keyboard shortcuts hint */
        .shortcuts {
            margin-top: 15px;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 5px;
            font-size: 11px;
            color: #808080;
        }
        
        .shortcuts-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .shortcut {
            display: inline-block;
            margin-right: 15px;
        }
        
        .shortcut-key {
            background: #3c3c3c;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>\u{1F3AC} Battle Replay Player</h1>
        <div class="metadata">
            <span>\u{1F4C5} ${this.data.timestamp}</span>
            <span>\u23F1\uFE0F Duration: ${(this.data.duration / 1e3).toFixed(2)}s</span>
            <span>\u{1F3AF} Events: ${this.data.events.length}</span>
            <span>\u{1F4D0} Terminal: ${this.data.metadata.cols}x${this.data.metadata.rows}</span>
            <span>\u{1F4BB} Command: ${this.data.metadata.command} ${(this.data.metadata.args || []).join(" ")}</span>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="progress-container">
            <div id="progressBar" class="progress-bar" onclick="seekToPosition(event)">
                <div id="progressFill" class="progress-fill"></div>
                <div id="progressHandle" class="progress-handle"></div>
            </div>
            <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
        </div>
        
        <div class="main-controls">
            <button id="playBtn" class="control-btn" onclick="togglePlay()">\u25B6 Play</button>
            <button class="control-btn secondary-btn" onclick="stop()">\u23F9 Stop</button>
            <button class="control-btn secondary-btn" onclick="jumpToStart()">\u23EE Start</button>
            <button class="control-btn secondary-btn" onclick="jumpToEnd()">\u23ED End</button>
        </div>
        
        <div class="speed-controls">
            <span>Speed:</span>
            <button class="speed-preset" onclick="setSpeed.call(this, 0.5)">0.5\xD7</button>
            <button class="speed-preset active" onclick="setSpeed.call(this, 1)">1\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 2)">2\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 4)">4\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 8)">8\xD7</button>
            <div class="speed-input-container">
                <span>Custom:</span>
                <input type="number" id="speedInput" value="1.0" min="0" max="50" step="0.1" onchange="setCustomSpeed()">
                <span>\xD7</span>
            </div>
        </div>
        
        <div class="status-container">
            <div id="statusDot" class="status-dot stopped"></div>
            <span id="statusText">Stopped</span>
            <span id="eventCounter">Event: 0/${this.data.events.length}</span>
        </div>
    </div>
    
    <div id="terminal"></div>
    
    <div id="eventLog" class="event-log">
        <strong>Event Log</strong> (most recent first)
    </div>
    
    <div id="eventDisplay"></div>
    
    <div class="shortcuts">
        <div class="shortcuts-title">\u2328\uFE0F Keyboard Shortcuts:</div>
        <span class="shortcut"><span class="shortcut-key">Space</span> Play/Pause</span>
        <span class="shortcut"><span class="shortcut-key">\u2190/\u2192</span> Skip -/+ 5s</span>
        <span class="shortcut"><span class="shortcut-key">\u2191/\u2193</span> Speed Up/Down</span>
        <span class="shortcut"><span class="shortcut-key">0-9</span> Jump to %</span>
    </div>
    
    <script>
        ${getPlaybackEngineSource()}
        
        // Replay data
        const replayData = ${JSON.stringify(this.data)};
        const events = replayData.events;
        const duration = replayData.duration;
        
        // Create unified playback engine
        const engine = new PlaybackEngine(events, duration, {
            speed: 1.0,
            onEvent: processEvent,
            onStateChange: updateDisplay,
            onProgress: updateDisplay
        });
        
        // DOM elements
        const terminal = document.getElementById('terminal');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const progressHandle = document.getElementById('progressHandle');
        const timeDisplay = document.getElementById('timeDisplay');
        const eventLog = document.getElementById('eventLog');
        const eventDisplay = document.getElementById('eventDisplay');
        const speedInput = document.getElementById('speedInput');
        const playBtn = document.getElementById('playBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const eventCounter = document.getElementById('eventCounter');
        
        // Initialize
        updateDisplay();
        
        function togglePlay() {
            if (engine.isPlaying()) {
                engine.pause();
            } else {
                engine.play();
            }
        }
        
        function play() {
            engine.play();
        }
        
        function pause() {
            engine.pause();
        }
        
        function stop() {
            engine.stop();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
        }
        
        function jumpToStart() {
            engine.jumpToStart();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
        }
        
        function jumpToEnd() {
            engine.jumpToEnd();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
            
            // Process all events to current point
            for (let i = 0; i < engine.getCurrentEventIndex(); i++) {
                processEvent(events[i], engine.getState());
            }
        }
        
        function setSpeed(speed) {
            engine.setSpeed(speed);
            speedInput.value = speed.toFixed(2);
            
            // Update active preset
            document.querySelectorAll('.speed-preset').forEach(btn => {
                btn.classList.remove('active');
            });
            this.classList.add('active');
        }
        
        function setCustomSpeed() {
            const speed = Math.max(0, parseFloat(speedInput.value));
            engine.setSpeed(speed);
            
            // Update active preset
            document.querySelectorAll('.speed-preset').forEach(btn => {
                btn.classList.remove('active');
            });
        }
        
        function seekToPosition(event) {
            const rect = progressBar.getBoundingClientRect();
            const position = (event.clientX - rect.left) / rect.width;
            const percent = position * 100;
            
            engine.seekToPercent(percent);
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
            
            // Process events up to current point
            for (let i = 0; i < engine.getCurrentEventIndex(); i++) {
                processEvent(events[i], engine.getState());
            }
        }
        
        function updateStatus(state, text) {
            statusDot.className = 'status-dot ' + state;
            statusText.textContent = text;
        }
        
        function updateDisplay() {
            const state = engine.getState();
            const progress = engine.getProgress();
            const currentTime = engine.getCurrentTime();
            
            // Update progress bar
            progressFill.style.width = progress + '%';
            progressHandle.style.left = progress + '%';
            
            // Update time display
            const currentMins = Math.floor(currentTime / 60000);
            const currentSecs = Math.floor((currentTime % 60000) / 1000);
            const totalMins = Math.floor(duration / 60000);
            const totalSecs = Math.floor((duration % 60000) / 1000);
            
            timeDisplay.textContent = 
                currentMins + ':' + currentSecs.toString().padStart(2, '0') + 
                ' / ' + 
                totalMins + ':' + totalSecs.toString().padStart(2, '0');
            
            // Update event counter
            eventCounter.textContent = 'Event: ' + state.currentEventIndex + '/' + events.length;
            
            // Update play button and status
            if (state.isPlaying) {
                updateStatus('playing', 'Playing');
                playBtn.textContent = '\u23F8 Pause';
            } else if (state.isPaused) {
                updateStatus('paused', 'Paused');
                playBtn.textContent = '\u25B6 Play';
            } else {
                updateStatus('stopped', 'Stopped');
                playBtn.textContent = '\u25B6 Play';
            }
        }
        
        function processEvent(event, state) {
            let logEntry = '<div class="event event-' + event.type + '">';
            logEntry += '[' + (event.timestamp / 1000).toFixed(2) + 's] ';
            
            switch(event.type) {
                case 'spawn':
                    logEntry += 'SPAWN: ' + event.data.command + ' ' + (event.data.args || []).join(' ');
                    break;
                    
                case 'output':
                    terminal.innerHTML += escapeHtml(event.data);
                    // Auto-scroll terminal
                    terminal.scrollTop = terminal.scrollHeight;
                    logEntry += 'OUTPUT: ' + event.data.length + ' bytes';
                    break;
                    
                case 'input':
                    logEntry += 'INPUT: ' + JSON.stringify(event.data);
                    break;
                    
                case 'key':
                    logEntry += 'KEY: ' + event.data;
                    break;
                    
                case 'resize':
                    logEntry += 'RESIZE: ' + event.data.cols + 'x' + event.data.rows;
                    break;
                    
                case 'screenshot':
                    logEntry += 'SCREENSHOT: ' + event.data.name;
                    break;
                    
                case 'expect':
                    logEntry += 'EXPECT: ' + (event.data.pattern || event.data);
                    break;
                    
                case 'exit':
                    logEntry += 'EXIT: Code ' + event.data;
                    break;
                    
                default:
                    logEntry += event.type.toUpperCase();
            }
            
            logEntry += '</div>';
            
            // Add to event log (prepend for most recent first)
            const currentLog = eventLog.innerHTML;
            const titleIndex = currentLog.indexOf('</strong>');
            if (titleIndex !== -1) {
                eventLog.innerHTML = currentLog.slice(0, titleIndex + 9) + 
                    logEntry + currentLog.slice(titleIndex + 9);
            }
            
            // Keep log size reasonable
            const logEvents = eventLog.querySelectorAll('.event');
            if (logEvents.length > 100) {
                logEvents[logEvents.length - 1].remove();
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    engine.skipBackward(5000);
                    break;
                case 'ArrowRight':
                    engine.skipForward(5000);
                    break;
                case 'ArrowUp':
                    engine.setSpeed(Math.min(50, engine.getSpeed() * 2));
                    speedInput.value = engine.getSpeed().toFixed(2);
                    break;
                case 'ArrowDown':
                    engine.setSpeed(Math.max(0.1, engine.getSpeed() / 2));
                    speedInput.value = engine.getSpeed().toFixed(2);
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    const percent = parseInt(e.key) * 10;
                    engine.seekToPercent(percent);
                    break;
            }
        });
    </script>
</body>
</html>`;
  }
  throw new Error(`Unsupported export format: ${format}`);
}

// src/Replay/index.ts
var Replay = class {
  data;
  events;
  startTime;
  constructor() {
    constructor.call(this);
  }
  record(event) {
    return record.call(this, event);
  }
  save(path5) {
    return save.call(this, path5);
  }
  load(path5) {
    return load.call(this, path5);
  }
  async play(options) {
    return play.call(this, options);
  }
  export(format) {
    return exportReplay.call(this, format);
  }
};

// src/Battle/constructor.ts
function constructor2(options = {}) {
  this.options = {
    cols: 80,
    rows: 24,
    cwd: process.cwd(),
    env: process.env,
    timeout: 1e4,
    screenshotDir: "./screenshots",
    logDir: "./logs",
    verbose: false,
    ...options
  };
  this.pty = null;
  this.output = "";
  this.screenshots = [];
  this.logs = [];
  this.startTime = Date.now();
  this.replay = new Replay();
  this.replay.data.metadata.cols = this.options.cols;
  this.replay.data.metadata.rows = this.options.rows;
  this.replay.data.metadata.env = { ...this.options.env };
}

// src/PTY/index.ts
function getRuntime() {
  if (typeof Bun !== "undefined") return "bun";
  if (typeof process !== "undefined" && process.versions?.node) return "node";
  return "unknown";
}
async function createPTY(command, args, options) {
  const runtime = getRuntime();
  if (runtime === "bun") {
    const { Ruspty } = await import("./Ruspty-UTTLTSEU.js");
    return new Ruspty(command, args, options);
  } else if (runtime === "node") {
    const { NodePTY } = await import("./NodePTY-GKVZDCDL.js");
    return new NodePTY(command, args, options);
  } else {
    throw new Error(`Unsupported runtime: ${runtime}`);
  }
}

// src/Battle/spawn.ts
async function spawn(command, args = []) {
  this.log("info", `Spawning: ${command} ${args.join(" ")}`);
  if (this.pty && !this.pty.killed) {
    this.pty.kill();
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  this.output = "";
  this.replay.record({
    type: "spawn",
    timestamp: 0,
    // Will be set by record method
    data: { command, args }
  });
  this.replay.data.metadata.command = command;
  this.replay.data.metadata.args = args;
  this.pty = await createPTY(command, args, {
    name: "xterm-256color",
    cols: this.options.cols,
    rows: this.options.rows,
    cwd: this.options.cwd,
    env: {
      ...this.options.env,
      TERM: "xterm-256color",
      FORCE_COLOR: "1"
    }
  });
  this.pty.onData((data) => {
    this.output += data;
    this.replay.record({
      type: "output",
      timestamp: 0,
      data
    });
    if (this.options.verbose) {
      process.stdout.write(data);
    }
    this.log("output", data);
  });
  this.pty.onExit((exitData) => {
    this.log("info", `Process exited with code: ${exitData.exitCode}`);
    this.exitCode = exitData.exitCode;
    this.replay.record({
      type: "exit",
      timestamp: 0,
      data: exitData.exitCode
    });
  });
}

// src/Battle/interact.ts
async function interact(handler) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      this.log("error", "Interaction timeout");
      reject(new Error("Interaction timeout"));
    }, this.options.timeout);
    const cleanup2 = () => {
      clearTimeout(timeout);
      this.pty.onData(() => {
      });
    };
    this.pty.onData(async (data) => {
      try {
        const response = await handler(data, this.output);
        if (response === null) {
          cleanup2();
          resolve();
        } else if (response) {
          this.log("input", response);
          this.pty.write(response);
        }
      } catch (error) {
        cleanup2();
        reject(error);
      }
    });
  });
}

// src/Battle/screenshot.ts
import fs3 from "fs";
import path2 from "path";
function screenshot(name) {
  const timestamp = Date.now();
  const filename = name || `screenshot-${timestamp}.txt`;
  const filepath = path2.join(this.options.screenshotDir, filename);
  fs3.mkdirSync(this.options.screenshotDir, { recursive: true });
  const screen = parseTerminalOutput(this.output);
  fs3.writeFileSync(filepath, this.output);
  const cleanPath = filepath.replace(".txt", "-clean.txt");
  fs3.writeFileSync(cleanPath, screen.clean);
  const htmlPath = filepath.replace(".txt", ".html");
  fs3.writeFileSync(htmlPath, screen.html);
  this.replay.record({
    type: "screenshot",
    timestamp: 0,
    data: { name: filename, path: filepath }
  });
  this.screenshots.push(filepath);
  this.log("info", `Screenshot saved: ${filepath}`);
  return filepath;
}
function parseTerminalOutput(output) {
  const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
  const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace;
            white-space: pre;
            padding: 20px;
        }
        .ansi-black { color: #000; }
        .ansi-red { color: #f00; }
        .ansi-green { color: #0f0; }
        .ansi-yellow { color: #ff0; }
        .ansi-blue { color: #00f; }
        .ansi-magenta { color: #f0f; }
        .ansi-cyan { color: #0ff; }
        .ansi-white { color: #fff; }
    </style>
</head>
<body>${convertAnsiToHtml(output)}</body>
</html>`;
  return { clean, html };
}
function convertAnsiToHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\x1b\[31m/g, '<span class="ansi-red">').replace(/\x1b\[32m/g, '<span class="ansi-green">').replace(/\x1b\[33m/g, '<span class="ansi-yellow">').replace(/\x1b\[34m/g, '<span class="ansi-blue">').replace(/\x1b\[35m/g, '<span class="ansi-magenta">').replace(/\x1b\[36m/g, '<span class="ansi-cyan">').replace(/\x1b\[0m/g, "</span>").replace(/\n/g, "<br>");
}

// src/Battle/expect.ts
async function expect(pattern, timeout = 2e3) {
  const startTime = Date.now();
  while (Date.now() - startTime < timeout) {
    const cleanOutput = this.output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
    let matches = false;
    if (typeof pattern === "string") {
      matches = cleanOutput.includes(pattern);
    } else {
      matches = pattern.test(cleanOutput);
    }
    if (matches) {
      this.replay.record({
        type: "expect",
        timestamp: 0,
        data: { pattern: pattern.toString(), matched: true }
      });
      this.log("info", `Pattern matched: ${pattern}`);
      return true;
    }
    await new Promise((resolve) => setTimeout(resolve, 50));
  }
  this.log("error", `Expected pattern not found after ${timeout}ms: ${pattern}`);
  this.screenshot("expect-failure");
  throw new Error(`Expected pattern not found: ${pattern}`);
}

// src/Battle/log.ts
import fs4 from "fs";
import path3 from "path";
function log(level, message) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}
`;
  if (!fs4.existsSync(this.options.logDir)) {
    fs4.mkdirSync(this.options.logDir, { recursive: true });
  }
  const logFile = path3.join(this.options.logDir, `battle-${this.startTime}.log`);
  fs4.appendFileSync(logFile, logEntry);
  this.logs.push(logEntry);
  if (this.options.verbose && level !== "output") {
    console.log(logEntry.trim());
  }
}

// src/Battle/cleanup.ts
function cleanup() {
  if (this.pty) {
    this.log("info", "Cleaning up PTY process");
    try {
      this.pty.kill();
    } catch (error) {
      this.log("warn", `Failed to kill PTY: ${error}`);
    }
    this.pty = null;
  }
}

// src/Battle/run.ts
import path4 from "path";
async function run(testFn) {
  const startTime = Date.now();
  let success = false;
  let error = null;
  try {
    this.log("info", "Starting test");
    await testFn(this);
    success = true;
    this.log("info", "Test completed successfully");
  } catch (err) {
    error = err;
    this.log("error", `Test failed: ${error.message}`);
    this.screenshot("test-failure");
  } finally {
    this.cleanup();
  }
  const duration = Date.now() - startTime;
  let replayPath;
  try {
    const replayFilename = `replay-${Date.now()}.json`;
    replayPath = path4.join(this.options.logDir || "./logs", replayFilename);
    this.replay.save(replayPath);
    this.log("info", `Replay saved: ${replayPath}`);
  } catch (e) {
    this.log("error", `Failed to save replay: ${e}`);
  }
  const result = {
    success,
    duration,
    output: this.output,
    screenshots: this.screenshots,
    logs: this.logs,
    error: error?.message || null,
    replayPath
  };
  return result;
}

// src/Battle/resize.ts
function resize(cols, rows) {
  if (!this.pty) {
    this.options.cols = cols;
    this.options.rows = rows;
    this.log("info", `Terminal size set to: ${cols}x${rows} (will apply on spawn)`);
    return;
  }
  this.log("info", `Resizing terminal: ${cols}x${rows}`);
  this.replay.record({
    type: "resize",
    timestamp: 0,
    data: { cols, rows }
  });
  const previousCols = this.options.cols;
  const previousRows = this.options.rows;
  this.options.cols = cols;
  this.options.rows = rows;
  this.pty.resize(cols, rows);
  setTimeout(() => {
    this.screenshot(`resize-${cols}x${rows}`);
  }, 100);
  this.log("info", `Terminal resized from ${previousCols}x${previousRows} to ${cols}x${rows}`);
}

// src/Battle/sendKey.ts
function sendKey(key) {
  if (!this.pty) {
    throw new Error("No PTY process to send keys to");
  }
  const keyMap = {
    // Arrow keys
    "up": "\x1B[A",
    "down": "\x1B[B",
    "right": "\x1B[C",
    "left": "\x1B[D",
    // Function keys
    "f1": "\x1BOP",
    "f2": "\x1BOQ",
    "f3": "\x1BOR",
    "f4": "\x1BOS",
    "f5": "\x1B[15~",
    "f6": "\x1B[17~",
    "f7": "\x1B[18~",
    "f8": "\x1B[19~",
    "f9": "\x1B[20~",
    "f10": "\x1B[21~",
    "f11": "\x1B[23~",
    "f12": "\x1B[24~",
    // Control keys
    "enter": "\r",
    "return": "\r",
    "tab": "	",
    "backspace": "\x7F",
    "delete": "\x1B[3~",
    "escape": "\x1B",
    "esc": "\x1B",
    "home": "\x1B[H",
    "end": "\x1B[F",
    "pageup": "\x1B[5~",
    "pagedown": "\x1B[6~",
    // Control combinations
    "ctrl+c": "",
    "ctrl+d": "",
    "ctrl+z": "",
    "ctrl+a": "",
    "ctrl+e": "",
    "ctrl+k": "\v",
    "ctrl+l": "\f",
    "ctrl+u": "",
    "ctrl+w": "",
    // Alt combinations
    "alt+b": "\x1Bb",
    "alt+f": "\x1Bf",
    "alt+d": "\x1Bd",
    // Special
    "space": " ",
    "clear": "\x1B[2J\x1B[H"
  };
  const sequence = keyMap[key.toLowerCase()] || key;
  this.replay.record({
    type: "key",
    timestamp: 0,
    data: key
  });
  this.replay.record({
    type: "input",
    timestamp: 0,
    data: sequence
  });
  this.log("input", `Sending key: ${key} (${sequence.replace(/\x1b/g, "^[").replace(/\r/g, "\\r").replace(/\n/g, "\\n")})`);
  this.pty.write(sequence);
}

// src/Battle/wait.ts
function wait(ms) {
  this.log("info", `Waiting ${ms}ms`);
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/Battle/write.ts
function write(data) {
  if (!this.pty) {
    throw new Error("No PTY process running. Call spawn() first.");
  }
  if (this.pty.killed) {
    throw new Error("PTY process has already exited");
  }
  this.log("input", `Writing: ${JSON.stringify(data)}`);
  this.replay.record({
    type: "input",
    timestamp: 0,
    data
  });
  this.pty.write(data);
}

// src/Battle/getCursor.ts
async function getCursor() {
  if (!this.pty) {
    throw new Error("No PTY process");
  }
  return new Promise((resolve) => {
    let response = "";
    const timeout = setTimeout(() => {
      this.log("warn", "Cursor position request timeout");
      resolve(null);
    }, 1e3);
    const handler = (data) => {
      response += data;
      const match = response.match(/\x1b\[(\d+);(\d+)R/);
      if (match) {
        clearTimeout(timeout);
        this.pty.onData(() => {
        });
        const position = {
          x: parseInt(match[2]) - 1,
          // Convert to 0-based
          y: parseInt(match[1]) - 1
        };
        this.log("info", `Cursor position: x=${position.x}, y=${position.y}`);
        resolve(position);
      }
    };
    this.pty.onData(handler);
    this.log("debug", "Requesting cursor position");
    this.pty.write("\x1B[6n");
  });
}

// src/Battle/index.ts
var Battle = class {
  options;
  pty;
  output;
  screenshots;
  logs;
  startTime;
  replay;
  constructor(options = {}) {
    constructor2.call(this, options);
  }
  async spawn(command, args) {
    return spawn.call(this, command, args);
  }
  interact(handler) {
    return interact.call(this, handler);
  }
  screenshot(name) {
    return screenshot.call(this, name);
  }
  async expect(pattern, timeout) {
    return expect.call(this, pattern, timeout);
  }
  log(level, message) {
    return log.call(this, level, message);
  }
  cleanup() {
    return cleanup.call(this);
  }
  async run(testFn) {
    return run.call(this, testFn);
  }
  resize(cols, rows) {
    return resize.call(this, cols, rows);
  }
  sendKey(key) {
    return sendKey.call(this, key);
  }
  write(data) {
    return write.call(this, data);
  }
  wait(ms) {
    return wait.call(this, ms);
  }
  async getCursor() {
    return getCursor.call(this);
  }
};
var Battle_default = Battle;

export {
  color,
  Replay,
  Battle,
  Battle_default
};
