import {
  __require
} from "./chunk-3RG5ZIWI.js";

// src/PTY/Ruspty.ts
var Pty;
var Ruspty = class {
  pty;
  fd;
  // Store file descriptor for Bun
  _killed = false;
  _pid;
  dataCallbacks = [];
  exitCallbacks = [];
  isBun = typeof Bun !== "undefined";
  constructor(command, args, options) {
    if (!Pty) {
      try {
        if (this.isBun) {
          const ruspty = __require("@akaoio/ruspty/index.js");
          Pty = ruspty.Pty;
        } else {
          const ruspty = __require("@akaoio/ruspty");
          Pty = ruspty.Pty;
        }
      } catch (err) {
        throw new Error(
          "@akaoio/ruspty is not installed or failed to load.\nRun: npm install @akaoio/ruspty\nNote: ARM64 support is included"
        );
      }
    }
    try {
      if (this.isBun) {
        this.pty = new Pty({
          command,
          args: args || [],
          envs: {
            // Note: raw API uses 'envs'
            ...process.env,
            ...options.env,
            TERM: options.name || "xterm-256color",
            FORCE_COLOR: "1",
            COLORTERM: "truecolor"
          },
          size: {
            rows: options.rows || 24,
            cols: options.cols || 80
          },
          onExit: (err, exitCode) => {
            this._killed = true;
            this.exitCallbacks.forEach((cb) => cb(exitCode || 0));
          }
        });
      } else {
        this.pty = new Pty({
          command,
          args: args || [],
          env: {
            // Note: wrapper API uses 'env'
            ...process.env,
            ...options.env,
            TERM: options.name || "xterm-256color",
            FORCE_COLOR: "1",
            COLORTERM: "truecolor"
          },
          size: {
            rows: options.rows || 24,
            cols: options.cols || 80
          },
          onExit: (err, exitCode) => {
            this._killed = true;
            this.exitCallbacks.forEach((cb) => cb(exitCode || 0));
          }
        });
      }
      this._pid = this.pty.pid;
      this.setupDataStream();
    } catch (err) {
      throw new Error(`Failed to create PTY: ${err.message}`);
    }
  }
  setupDataStream() {
    try {
      if (this.isBun) {
        this.fd = this.pty.takeFd();
        const fs = __require("fs");
        const checkOutput = () => {
          if (this._killed) return;
          try {
            const buffer = Buffer.alloc(4096);
            const bytesRead = fs.readSync(this.fd, buffer, 0, 4096, null);
            if (bytesRead > 0) {
              const text = buffer.slice(0, bytesRead).toString();
              this.dataCallbacks.forEach((cb) => cb(text));
            }
          } catch (err) {
            if (err.code !== "EAGAIN" && err.code !== "EWOULDBLOCK") {
              if (err.code === "EBADF" || err.code === "EIO") {
                this._killed = true;
                return;
              }
            }
          }
          if (!this._killed) {
            setTimeout(checkOutput, 10);
          }
        };
        setTimeout(checkOutput, 0);
      } else {
        const stream = this.pty.read;
        if (stream && typeof stream.on === "function") {
          stream.on("data", (data) => {
            const text = data.toString();
            this.dataCallbacks.forEach((cb) => cb(text));
          });
          stream.on("error", (err) => {
            if (err.code === "EIO") {
              stream.emit("end");
            } else {
              console.error("PTY stream error:", err);
            }
          });
          stream.on("end", () => {
            this._killed = true;
          });
        } else {
          throw new Error("Stream interface not available");
        }
      }
    } catch (err) {
      console.error("Failed to setup data stream:", err);
      if (!this._killed) {
        this._killed = true;
        this.exitCallbacks.forEach((cb) => cb(1));
      }
    }
  }
  onData(callback) {
    this.dataCallbacks.push(callback);
  }
  onExit(callback) {
    this.exitCallbacks.push(callback);
    if (this._killed) {
      callback(0);
    }
  }
  write(data) {
    if (!this._killed) {
      try {
        if (this.isBun && this.fd !== void 0) {
          const fs = __require("fs");
          fs.writeSync(this.fd, data);
        } else if (this.pty) {
          this.pty.write.write(data);
        }
      } catch (err) {
        console.error("Write error:", err);
      }
    }
  }
  resize(cols, rows) {
    if (!this._killed && this.pty && this.pty.resize) {
      try {
        this.pty.resize({ cols, rows });
      } catch (err) {
      }
    }
  }
  kill(signal) {
    if (!this._killed && this.pty) {
      try {
        if (this.pty.kill) {
          this.pty.kill();
        }
        this._killed = true;
      } catch (err) {
      }
    }
  }
  get pid() {
    return this._pid;
  }
  get killed() {
    return this._killed;
  }
};
var Ruspty_default = Ruspty;
export {
  Ruspty,
  Ruspty_default as default
};
