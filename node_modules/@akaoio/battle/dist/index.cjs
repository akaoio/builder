"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/Replay/constructor.ts
function constructor() {
  this.events = [];
  this.startTime = Date.now();
  this.data = {
    version: "1.0.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    duration: 0,
    events: [],
    metadata: {
      cols: 80,
      rows: 24,
      command: "",
      args: [],
      env: {}
    }
  };
}
var init_constructor = __esm({
  "src/Replay/constructor.ts"() {
    "use strict";
  }
});

// src/Replay/record.ts
function record(event) {
  const timestampedEvent = {
    ...event,
    timestamp: Date.now() - this.startTime
  };
  this.events.push(timestampedEvent);
}
var init_record = __esm({
  "src/Replay/record.ts"() {
    "use strict";
  }
});

// src/Replay/save.ts
function save(filePath) {
  const dir = import_path.default.dirname(filePath);
  if (!import_fs.default.existsSync(dir)) {
    import_fs.default.mkdirSync(dir, { recursive: true });
  }
  this.data.events = this.events;
  this.data.duration = Date.now() - this.startTime;
  const json = JSON.stringify(this.data, null, 2);
  import_fs.default.writeFileSync(filePath, json);
  return filePath;
}
var import_fs, import_path;
var init_save = __esm({
  "src/Replay/save.ts"() {
    "use strict";
    import_fs = __toESM(require("fs"), 1);
    import_path = __toESM(require("path"), 1);
  }
});

// src/Replay/load.ts
function load(filePath) {
  const json = import_fs2.default.readFileSync(filePath, "utf-8");
  this.data = JSON.parse(json);
  this.events = this.data.events || [];
  if (!this.data.version || !this.data.events) {
    throw new Error("Invalid replay file format");
  }
}
var import_fs2;
var init_load = __esm({
  "src/Replay/load.ts"() {
    "use strict";
    import_fs2 = __toESM(require("fs"), 1);
  }
});

// node_modules/chalk/source/vendor/ansi-styles/index.js
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ANSI_BACKGROUND_OFFSET, wrapAnsi16, wrapAnsi256, wrapAnsi16m, styles, modifierNames, foregroundColorNames, backgroundColorNames, colorNames, ansiStyles, ansi_styles_default;
var init_ansi_styles = __esm({
  "node_modules/chalk/source/vendor/ansi-styles/index.js"() {
    "use strict";
    ANSI_BACKGROUND_OFFSET = 10;
    wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
    wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        gray: [90, 39],
        // Alias of `blackBright`
        grey: [90, 39],
        // Alias of `blackBright`
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgGray: [100, 49],
        // Alias of `bgBlackBright`
        bgGrey: [100, 49],
        // Alias of `bgBlackBright`
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    modifierNames = Object.keys(styles.modifier);
    foregroundColorNames = Object.keys(styles.color);
    backgroundColorNames = Object.keys(styles.bgColor);
    colorNames = [...foregroundColorNames, ...backgroundColorNames];
    ansiStyles = assembleStyles();
    ansi_styles_default = ansiStyles;
  }
});

// node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env)) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var import_node_process, import_node_os, import_node_tty, env, flagForceColor, supportsColor, supports_color_default;
var init_supports_color = __esm({
  "node_modules/chalk/source/vendor/supports-color/index.js"() {
    "use strict";
    import_node_process = __toESM(require("process"), 1);
    import_node_os = __toESM(require("os"), 1);
    import_node_tty = __toESM(require("tty"), 1);
    ({ env } = import_node_process.default);
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    supportsColor = {
      stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
      stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
    };
    supports_color_default = supportsColor;
  }
});

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
var init_utilities = __esm({
  "node_modules/chalk/source/utilities.js"() {
    "use strict";
  }
});

// node_modules/chalk/source/index.js
var source_exports = {};
__export(source_exports, {
  Chalk: () => Chalk,
  backgroundColorNames: () => backgroundColorNames,
  backgroundColors: () => backgroundColorNames,
  chalkStderr: () => chalkStderr,
  colorNames: () => colorNames,
  colors: () => colorNames,
  default: () => source_default,
  foregroundColorNames: () => foregroundColorNames,
  foregroundColors: () => foregroundColorNames,
  modifierNames: () => modifierNames,
  modifiers: () => modifierNames,
  supportsColor: () => stdoutColor,
  supportsColorStderr: () => stderrColor
});
function createChalk(options) {
  return chalkFactory(options);
}
var stdoutColor, stderrColor, GENERATOR, STYLER, IS_EMPTY, levelMapping, styles2, applyOptions, Chalk, chalkFactory, getModelAnsi, usedModels, proto, createStyler, createBuilder, applyStyle, chalk, chalkStderr, source_default;
var init_source = __esm({
  "node_modules/chalk/source/index.js"() {
    "use strict";
    init_ansi_styles();
    init_supports_color();
    init_utilities();
    init_ansi_styles();
    ({ stdout: stdoutColor, stderr: stderrColor } = supports_color_default);
    GENERATOR = Symbol("GENERATOR");
    STYLER = Symbol("STYLER");
    IS_EMPTY = Symbol("IS_EMPTY");
    levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    styles2 = /* @__PURE__ */ Object.create(null);
    applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    Chalk = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    chalkFactory = (options) => {
      const chalk3 = (...strings) => strings.join(" ");
      applyOptions(chalk3, options);
      Object.setPrototypeOf(chalk3, createChalk.prototype);
      return chalk3;
    };
    Object.setPrototypeOf(createChalk.prototype, Function.prototype);
    for (const [styleName, style] of Object.entries(ansi_styles_default)) {
      styles2[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles2.visible = {
      get() {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    getModelAnsi = (model, level, type, ...arguments_) => {
      if (model === "rgb") {
        if (level === "ansi16m") {
          return ansi_styles_default[type].ansi16m(...arguments_);
        }
        if (level === "ansi256") {
          return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
        }
        return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
      }
      if (model === "hex") {
        return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
      }
      return ansi_styles_default[type][model](...arguments_);
    };
    usedModels = ["rgb", "hex", "ansi256"];
    for (const model of usedModels) {
      styles2[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
            return createBuilder(this, styler, this[IS_EMPTY]);
          };
        }
      };
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles2[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
            return createBuilder(this, styler, this[IS_EMPTY]);
          };
        }
      };
    }
    proto = Object.defineProperties(() => {
    }, {
      ...styles2,
      level: {
        enumerable: true,
        get() {
          return this[GENERATOR].level;
        },
        set(level) {
          this[GENERATOR].level = level;
        }
      }
    });
    createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      Object.setPrototypeOf(builder, proto);
      builder[GENERATOR] = self;
      builder[STYLER] = _styler;
      builder[IS_EMPTY] = _isEmpty;
      return builder;
    };
    applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self[IS_EMPTY] ? "" : string;
      }
      let styler = self[STYLER];
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.includes("\x1B")) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    Object.defineProperties(createChalk.prototype, styles2);
    chalk = createChalk();
    chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
    source_default = chalk;
  }
});

// src/utils/colors.ts
var colors, createColorFunction, color, chalk2;
var init_colors = __esm({
  "src/utils/colors.ts"() {
    "use strict";
    colors = {
      reset: "\x1B[0m",
      red: "\x1B[31m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      blue: "\x1B[34m",
      magenta: "\x1B[35m",
      cyan: "\x1B[36m",
      gray: "\x1B[90m",
      bgRed: "\x1B[41m",
      bgGreen: "\x1B[42m",
      bgYellow: "\x1B[43m",
      bgBlue: "\x1B[44m",
      bold: "\x1B[1m",
      dim: "\x1B[2m"
    };
    createColorFunction = (colorCode) => {
      const fn = (text) => `${colorCode}${text}${colors.reset}`;
      fn.bold = (text) => `${colorCode}${colors.bold}${text}${colors.reset}`;
      fn.dim = (text) => `${colorCode}${colors.dim}${text}${colors.reset}`;
      return fn;
    };
    color = {
      red: createColorFunction(colors.red),
      green: createColorFunction(colors.green),
      yellow: createColorFunction(colors.yellow),
      blue: createColorFunction(colors.blue),
      magenta: createColorFunction(colors.magenta),
      cyan: createColorFunction(colors.cyan),
      gray: createColorFunction(colors.gray),
      bold: (text) => `${colors.bold}${text}${colors.reset}`,
      dim: (text) => `${colors.dim}${text}${colors.reset}`,
      bgRed: (text) => `${colors.bgRed}${text}${colors.reset}`,
      bgGreen: (text) => `${colors.bgGreen}${text}${colors.reset}`,
      bgYellow: (text) => `${colors.bgYellow}${text}${colors.reset}`,
      bgBlue: (text) => `${colors.bgBlue}${text}${colors.reset}`,
      white: (text) => text
      // White is default
    };
    chalk2 = color;
    try {
      const loadChalk = async () => {
        try {
          const chalkModule = await Promise.resolve().then(() => (init_source(), source_exports));
          chalk2 = chalkModule.default || chalkModule;
        } catch {
          chalk2 = color;
        }
      };
      loadChalk().catch(() => {
      });
    } catch {
      chalk2 = color;
    }
  }
});

// src/Replay/PlaybackEngine.ts
function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1e3);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, "0")}`;
}
function getEventDescription(event) {
  switch (event.type) {
    case "spawn":
      return `SPAWN ${event.data.command} ${event.data.args?.join(" ") || ""}`;
    case "output":
      return `OUTPUT (${event.data.length} bytes)`;
    case "input":
      return `INPUT ${JSON.stringify(event.data)}`;
    case "key":
      return `KEY ${event.data}`;
    case "resize":
      return `RESIZE ${event.data.cols}x${event.data.rows}`;
    case "screenshot":
      return `SCREENSHOT ${event.data.name}`;
    case "expect":
      return `EXPECT ${event.data.pattern || event.data}`;
    case "exit":
      return `EXIT code ${event.data}`;
    default:
      return event.type.toUpperCase();
  }
}
var PlaybackEngine;
var init_PlaybackEngine = __esm({
  "src/Replay/PlaybackEngine.ts"() {
    "use strict";
    PlaybackEngine = class {
      events;
      duration;
      state;
      options;
      animationFrame = null;
      lastFrameTime = 0;
      constructor(events, duration, options = {}) {
        this.events = events;
        this.duration = duration;
        this.options = {
          speed: 1,
          verbose: false,
          ...options
        };
        this.state = {
          isPlaying: false,
          isPaused: false,
          speed: this.options.speed || 1,
          currentEventIndex: 0,
          currentTime: 0,
          startTime: 0,
          lastPlayTime: 0
        };
      }
      // Core playback controls
      play() {
        if (this.state.isPlaying) return;
        this.state.isPlaying = true;
        this.state.isPaused = false;
        this.state.startTime = Date.now() - this.state.currentTime;
        this.state.lastPlayTime = Date.now();
        this.notifyStateChange();
        this.scheduleNextFrame();
      }
      pause() {
        if (!this.state.isPlaying) return;
        this.state.isPlaying = false;
        this.state.isPaused = true;
        if (this.animationFrame) {
          if (typeof cancelAnimationFrame !== "undefined") {
            cancelAnimationFrame(this.animationFrame);
          } else if (this.animationFrame) {
            clearTimeout(this.animationFrame);
          }
          this.animationFrame = null;
        }
        this.notifyStateChange();
      }
      stop() {
        this.pause();
        this.state.currentEventIndex = 0;
        this.state.currentTime = 0;
        this.state.isPaused = false;
        this.notifyStateChange();
        this.notifyProgress();
      }
      restart() {
        this.stop();
        this.play();
      }
      // Speed control
      setSpeed(speed) {
        this.state.speed = Math.max(0, Math.min(50, speed));
        this.notifyStateChange();
      }
      getSpeed() {
        return this.state.speed;
      }
      // Seeking controls
      seek(timeMs) {
        const targetTime = Math.max(0, Math.min(this.duration, timeMs));
        this.state.currentTime = targetTime;
        this.state.currentEventIndex = 0;
        for (let i = 0; i < this.events.length; i++) {
          if (this.events[i].timestamp > targetTime) {
            break;
          }
          this.state.currentEventIndex = i;
        }
        for (let i = 0; i < this.state.currentEventIndex; i++) {
          this.notifyEvent(this.events[i]);
        }
        this.notifyStateChange();
        this.notifyProgress();
      }
      seekToPercent(percent) {
        const targetTime = percent / 100 * this.duration;
        this.seek(targetTime);
      }
      skipForward(ms = 1e3) {
        this.seek(this.state.currentTime + ms);
      }
      skipBackward(ms = 1e3) {
        this.seek(this.state.currentTime - ms);
      }
      jumpToStart() {
        this.seek(0);
      }
      jumpToEnd() {
        this.seek(this.duration);
        this.state.currentEventIndex = this.events.length;
      }
      // State getters
      getState() {
        return { ...this.state };
      }
      getCurrentTime() {
        return this.state.currentTime;
      }
      getDuration() {
        return this.duration;
      }
      getProgress() {
        return this.duration > 0 ? this.state.currentTime / this.duration * 100 : 0;
      }
      getCurrentEventIndex() {
        return this.state.currentEventIndex;
      }
      getTotalEvents() {
        return this.events.length;
      }
      isPlaying() {
        return this.state.isPlaying;
      }
      isPaused() {
        return this.state.isPaused;
      }
      // Private methods for animation and event processing
      scheduleNextFrame() {
        if (!this.state.isPlaying) return;
        const now = Date.now();
        const deltaTime = now - this.state.lastPlayTime;
        this.state.lastPlayTime = now;
        if (this.state.speed > 0) {
          this.state.currentTime += deltaTime * this.state.speed;
          while (this.state.currentEventIndex < this.events.length) {
            const event = this.events[this.state.currentEventIndex];
            if (event.timestamp > this.state.currentTime) {
              break;
            }
            this.notifyEvent(event);
            this.state.currentEventIndex++;
          }
          this.notifyProgress();
        }
        if (this.state.currentTime >= this.duration || this.state.currentEventIndex >= this.events.length) {
          this.state.isPlaying = false;
          this.state.currentTime = this.duration;
          this.notifyStateChange();
          this.notifyProgress();
          return;
        }
        if (typeof requestAnimationFrame !== "undefined") {
          this.animationFrame = requestAnimationFrame(() => this.scheduleNextFrame());
        } else {
          this.animationFrame = setTimeout(() => this.scheduleNextFrame(), 16);
        }
      }
      notifyEvent(event) {
        if (this.options.onEvent) {
          this.options.onEvent(event, this.getState());
        }
      }
      notifyStateChange() {
        if (this.options.onStateChange) {
          this.options.onStateChange(this.getState());
        }
      }
      notifyProgress() {
        if (this.options.onProgress) {
          this.options.onProgress(this.getProgress(), this.getState());
        }
      }
      // Cleanup
      destroy() {
        this.stop();
        this.options = {};
      }
    };
  }
});

// src/Replay/play.ts
async function play(options = {}) {
  const replayData = this.data;
  const events = this.events;
  const totalDuration = replayData.duration;
  const totalEvents = events.length;
  const engine = new PlaybackEngine(events, totalDuration, {
    speed: options.speed || 1,
    verbose: options.verbose,
    onEvent: (event, state) => executeEvent(event, state),
    onStateChange: (state) => updateStatusLine(state),
    onProgress: (progress, state) => updateStatusLine(state)
  });
  let replayOutput = "";
  const replayPty = {
    write: (data) => {
    },
    resize: (cols, rows) => {
    },
    kill: () => {
    },
    killed: false
  };
  console.clear();
  showHeader(replayData, totalDuration, totalEvents);
  showControls();
  updateStatusLine(engine.getState());
  if (process.stdin.isTTY) {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();
  const handleKeypress = (chunk) => {
    const key = chunk.toString();
    switch (key) {
      case " ":
        if (engine.isPlaying()) {
          engine.pause();
        } else {
          engine.play();
        }
        break;
      case "s":
        engine.stop();
        clearTerminal();
        break;
      case "r":
        engine.restart();
        clearTerminal();
        break;
      case "e":
        engine.jumpToEnd();
        break;
      case "+":
      // Speed up
      case "=":
        engine.setSpeed(Math.min(50, engine.getSpeed() * 2));
        break;
      case "-":
        engine.setSpeed(Math.max(0.1, engine.getSpeed() / 2));
        break;
      case "0":
        engine.setSpeed(0);
        engine.pause();
        break;
      case "1":
        engine.setSpeed(1);
        break;
      case "2":
        engine.setSpeed(2);
        break;
      case "4":
        engine.setSpeed(4);
        break;
      case "\x1B":
      // Escape - quit
      case "q":
        cleanup2();
        process.exit(0);
        break;
      case "\x1B[C":
        engine.skipForward(1e3);
        break;
      case "\x1B[D":
        engine.skipBackward(1e3);
        break;
    }
  };
  process.stdin.on("data", handleKeypress);
  function executeEvent(event, state) {
    const eventDisplay = getEventDescription(event);
    process.stdout.write("\x1B[s");
    process.stdout.write("\x1B[H");
    process.stdout.write("\x1B[12;1H");
    process.stdout.write("\x1B[K");
    process.stdout.write(`\u{1F4FA} Event: ${color.cyan(eventDisplay)}`);
    process.stdout.write("\x1B[u");
    switch (event.type) {
      case "output":
        process.stdout.write("\x1B[14;1H");
        process.stdout.write(event.data);
        break;
      case "input":
        replayOutput += event.data;
        break;
      case "resize":
        process.stdout.write("\x1B[s");
        process.stdout.write("\x1B[12;1H");
        process.stdout.write("\x1B[K");
        process.stdout.write(`\u{1F4D0} Terminal resized to ${event.data.cols}x${event.data.rows}`);
        process.stdout.write("\x1B[u");
        break;
      case "key":
        process.stdout.write("\x1B[s");
        process.stdout.write("\x1B[13;1H");
        process.stdout.write("\x1B[K");
        process.stdout.write(`\u2328\uFE0F  Key pressed: ${color.green(event.data)}`);
        process.stdout.write("\x1B[u");
        break;
    }
  }
  function updateStatusLine(state) {
    const progress = engine.getProgress();
    const progressBar = createProgressBar(progress);
    const currentTimeStr = formatTime(engine.getCurrentTime());
    const totalTimeStr = formatTime(totalDuration);
    const statusIcon = state.isPlaying ? "\u25B6\uFE0F" : state.isPaused ? "\u23F8\uFE0F" : "\u23F9\uFE0F";
    const speedDisplay = state.speed === 0 ? "\u23F8\uFE0F 0\xD7" : `\u{1F680} ${state.speed}\xD7`;
    process.stdout.write("\x1B[s");
    process.stdout.write("\x1B[10;1H");
    process.stdout.write("\x1B[K");
    process.stdout.write(
      `${statusIcon} ${progressBar} ${color.yellow(currentTimeStr)}/${color.yellow(totalTimeStr)} ${speedDisplay} [${state.currentEventIndex}/${totalEvents}]`
    );
    process.stdout.write("\x1B[u");
  }
  function clearTerminal() {
    console.clear();
    showHeader(replayData, totalDuration, totalEvents);
    showControls();
    updateStatusLine(engine.getState());
  }
  function cleanup2() {
    engine.destroy();
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(false);
    }
    process.stdin.pause();
    console.clear();
    console.log(color.green("Battle Replay Player - Goodbye!"));
  }
  process.on("SIGINT", cleanup2);
  process.on("SIGTERM", cleanup2);
  if (!options.manual) {
    engine.play();
  }
  return new Promise((resolve) => {
    const checkComplete = () => {
      const state = engine.getState();
      if (!state.isPlaying && state.currentEventIndex >= totalEvents) {
        cleanup2();
        resolve();
      } else {
        setTimeout(checkComplete, 100);
      }
    };
    if (options.manual) {
    } else {
      checkComplete();
    }
  });
}
function showHeader(data, duration, totalEvents) {
  console.log(color.blue.bold("\u{1F3AC} Battle Replay Player - YouTube Style Controls"));
  console.log(color.gray(`\u{1F4FC} File: ${data.version} | \u{1F4C5} ${data.timestamp}`));
  console.log(color.gray(`\u23F1\uFE0F  Duration: ${formatTime(duration)} | \u{1F3AF} Events: ${totalEvents}`));
  console.log("");
}
function showControls() {
  console.log(color.cyan.bold("\u{1F3AE} CONTROLS:"));
  console.log(color.white("  SPACE") + color.gray(" - Play/Pause  ") + color.white("S") + color.gray(" - Stop  ") + color.white("R") + color.gray(" - Restart  ") + color.white("E") + color.gray(" - End"));
  console.log(color.white("  +/-  ") + color.gray(" - Speed Up/Down  ") + color.white("0-4") + color.gray(" - Speed Presets  ") + color.white("\u2190\u2192") + color.gray(" - Skip"));
  console.log(color.white("  Q/ESC") + color.gray(" - Quit"));
  console.log("");
}
function createProgressBar(percent, width = 40) {
  const filled = Math.round(percent / 100 * width);
  const empty = width - filled;
  const filledBar = "\u2588".repeat(filled);
  const emptyBar = "\u2591".repeat(empty);
  return color.red(filledBar) + color.gray(emptyBar) + ` ${percent.toFixed(1)}%`;
}
var init_play = __esm({
  "src/Replay/play.ts"() {
    "use strict";
    init_colors();
    init_PlaybackEngine();
  }
});

// src/Replay/getPlaybackEngineSource.ts
function getPlaybackEngineSource() {
  return `
// Unified PlaybackEngine for consistent replay behavior
class PlaybackEngine {
    constructor(events, duration, options = {}) {
        this.events = events;
        this.duration = duration;
        this.options = {
            speed: 1.0,
            verbose: false,
            ...options
        };
        
        this.state = {
            isPlaying: false,
            isPaused: false,
            speed: this.options.speed || 1.0,
            currentEventIndex: 0,
            currentTime: 0,
            startTime: 0,
            lastPlayTime: 0
        };
        
        this.animationFrame = null;
        this.lastFrameTime = 0;
    }

    // Core playback controls
    play() {
        if (this.state.isPlaying) return;
        
        this.state.isPlaying = true;
        this.state.isPaused = false;
        this.state.startTime = Date.now() - this.state.currentTime;
        this.state.lastPlayTime = Date.now();
        
        this.notifyStateChange();
        this.scheduleNextFrame();
    }

    pause() {
        if (!this.state.isPlaying) return;
        
        this.state.isPlaying = false;
        this.state.isPaused = true;
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
        
        this.notifyStateChange();
    }

    stop() {
        this.pause();
        this.state.currentEventIndex = 0;
        this.state.currentTime = 0;
        this.state.isPaused = false;
        this.notifyStateChange();
        this.notifyProgress();
    }

    restart() {
        this.stop();
        this.play();
    }

    // Speed control
    setSpeed(speed) {
        this.state.speed = Math.max(0, Math.min(50, speed));
        this.notifyStateChange();
    }

    getSpeed() {
        return this.state.speed;
    }

    // Seeking controls
    seek(timeMs) {
        const targetTime = Math.max(0, Math.min(this.duration, timeMs));
        this.state.currentTime = targetTime;
        
        // Find the appropriate event index
        this.state.currentEventIndex = 0;
        for (let i = 0; i < this.events.length; i++) {
            if (this.events[i].timestamp > targetTime) {
                break;
            }
            this.state.currentEventIndex = i;
        }
        
        // Process all events up to this point
        for (let i = 0; i < this.state.currentEventIndex; i++) {
            this.notifyEvent(this.events[i]);
        }
        
        this.notifyStateChange();
        this.notifyProgress();
    }

    seekToPercent(percent) {
        const targetTime = (percent / 100) * this.duration;
        this.seek(targetTime);
    }

    skipForward(ms = 1000) {
        this.seek(this.state.currentTime + ms);
    }

    skipBackward(ms = 1000) {
        this.seek(this.state.currentTime - ms);
    }

    jumpToStart() {
        this.seek(0);
    }

    jumpToEnd() {
        this.seek(this.duration);
        this.state.currentEventIndex = this.events.length;
    }

    // State getters
    getState() {
        return { ...this.state };
    }

    getCurrentTime() {
        return this.state.currentTime;
    }

    getDuration() {
        return this.duration;
    }

    getProgress() {
        return this.duration > 0 ? (this.state.currentTime / this.duration) * 100 : 0;
    }

    getCurrentEventIndex() {
        return this.state.currentEventIndex;
    }

    getTotalEvents() {
        return this.events.length;
    }

    isPlaying() {
        return this.state.isPlaying;
    }

    isPaused() {
        return this.state.isPaused;
    }

    // Private methods for animation and event processing
    scheduleNextFrame() {
        if (!this.state.isPlaying) return;
        
        const now = Date.now();
        const deltaTime = now - this.state.lastPlayTime;
        this.state.lastPlayTime = now;
        
        // Update current time based on speed
        if (this.state.speed > 0) {
            this.state.currentTime += deltaTime * this.state.speed;
            
            // Process events up to current time
            while (this.state.currentEventIndex < this.events.length) {
                const event = this.events[this.state.currentEventIndex];
                if (event.timestamp > this.state.currentTime) {
                    break;
                }
                
                this.notifyEvent(event);
                this.state.currentEventIndex++;
            }
            
            this.notifyProgress();
        }
        
        // Check if playback is complete
        if (this.state.currentTime >= this.duration || 
            this.state.currentEventIndex >= this.events.length) {
            this.state.isPlaying = false;
            this.state.currentTime = this.duration;
            this.notifyStateChange();
            this.notifyProgress();
            return;
        }
        
        // Schedule next frame
        this.animationFrame = requestAnimationFrame(() => this.scheduleNextFrame());
    }

    notifyEvent(event) {
        if (this.options.onEvent) {
            this.options.onEvent(event, this.getState());
        }
    }

    notifyStateChange() {
        if (this.options.onStateChange) {
            this.options.onStateChange(this.getState());
        }
    }

    notifyProgress() {
        if (this.options.onProgress) {
            this.options.onProgress(this.getProgress(), this.getState());
        }
    }

    // Cleanup
    destroy() {
        this.stop();
        this.options = {};
    }
}
`;
}
var init_getPlaybackEngineSource = __esm({
  "src/Replay/getPlaybackEngineSource.ts"() {
    "use strict";
  }
});

// src/Replay/export.ts
function exportReplay(format) {
  if (format === "json") {
    return JSON.stringify(this.data, null, 2);
  }
  if (format === "html") {
    return `<!DOCTYPE html>
<html>
<head>
    <title>Battle Replay - ${this.data.timestamp}</title>
    <style>
        body {
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Cascadia Code', 'Courier New', monospace;
            padding: 20px;
            margin: 0;
        }
        
        .header {
            margin-bottom: 20px;
            padding: 15px;
            background: #2d2d30;
            border-radius: 8px;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            color: #007acc;
        }
        
        .metadata {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #cccccc;
        }
        
        #terminal {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            min-height: 400px;
            max-height: 600px;
            white-space: pre-wrap;
            overflow-y: auto;
            font-family: 'Cascadia Code', 'SF Mono', 'Monaco', 'Inconsolata', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid #3c3c3c;
        }
        
        .controls-container {
            background: #2d2d30;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .main-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            min-width: 60px;
        }
        
        .control-btn:hover {
            background: #005a9e;
        }
        
        .control-btn:active {
            background: #004578;
        }
        
        .control-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .secondary-btn {
            background: #6c757d;
            padding: 8px 12px;
            font-size: 12px;
        }
        
        .secondary-btn:hover {
            background: #545b62;
        }
        
        .progress-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .progress-bar {
            flex: 1;
            height: 8px;
            background: #444;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }
        
        .progress-fill {
            height: 100%;
            background: #007acc;
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .progress-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: #007acc;
            border-radius: 50%;
            cursor: grab;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .progress-bar:hover .progress-handle {
            opacity: 1;
        }
        
        .progress-handle:active {
            cursor: grabbing;
        }
        
        .time-display {
            font-family: 'Cascadia Code', monospace;
            font-size: 14px;
            color: #cccccc;
            min-width: 100px;
        }
        
        .speed-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .speed-preset {
            background: #555;
            border: 1px solid #666;
            color: #ccc;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .speed-preset:hover {
            background: #666;
        }
        
        .speed-preset.active {
            background: #007acc;
            border-color: #007acc;
            color: white;
        }
        
        .speed-input-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #speedInput {
            width: 60px;
            padding: 5px;
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 3px;
            color: #d4d4d4;
            font-size: 12px;
        }
        
        .event-log {
            background: #252526;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            font-family: 'Cascadia Code', monospace;
        }
        
        .event {
            padding: 2px 0;
            border-bottom: 1px solid #3c3c3c;
        }
        
        .event-spawn { color: #dcdcaa; }
        .event-output { color: #9cdcfe; }
        .event-input { color: #ce9178; }
        .event-key { color: #b5cea8; }
        .event-resize { color: #c586c0; }
        .event-screenshot { color: #608b4e; }
        .event-expect { color: #d7ba7d; }
        .event-exit { color: #f48771; }
        
        .status-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #555;
        }
        
        .status-dot.playing { background: #4ec9b0; animation: pulse 1s infinite; }
        .status-dot.paused { background: #ffcc00; }
        .status-dot.stopped { background: #f48771; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #eventCounter {
            margin-left: auto;
            color: #808080;
        }
        
        /* Keyboard shortcuts hint */
        .shortcuts {
            margin-top: 15px;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 5px;
            font-size: 11px;
            color: #808080;
        }
        
        .shortcuts-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .shortcut {
            display: inline-block;
            margin-right: 15px;
        }
        
        .shortcut-key {
            background: #3c3c3c;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>\u{1F3AC} Battle Replay Player</h1>
        <div class="metadata">
            <span>\u{1F4C5} ${this.data.timestamp}</span>
            <span>\u23F1\uFE0F Duration: ${(this.data.duration / 1e3).toFixed(2)}s</span>
            <span>\u{1F3AF} Events: ${this.data.events.length}</span>
            <span>\u{1F4D0} Terminal: ${this.data.metadata.cols}x${this.data.metadata.rows}</span>
            <span>\u{1F4BB} Command: ${this.data.metadata.command} ${(this.data.metadata.args || []).join(" ")}</span>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="progress-container">
            <div id="progressBar" class="progress-bar" onclick="seekToPosition(event)">
                <div id="progressFill" class="progress-fill"></div>
                <div id="progressHandle" class="progress-handle"></div>
            </div>
            <div id="timeDisplay" class="time-display">0:00 / 0:00</div>
        </div>
        
        <div class="main-controls">
            <button id="playBtn" class="control-btn" onclick="togglePlay()">\u25B6 Play</button>
            <button class="control-btn secondary-btn" onclick="stop()">\u23F9 Stop</button>
            <button class="control-btn secondary-btn" onclick="jumpToStart()">\u23EE Start</button>
            <button class="control-btn secondary-btn" onclick="jumpToEnd()">\u23ED End</button>
        </div>
        
        <div class="speed-controls">
            <span>Speed:</span>
            <button class="speed-preset" onclick="setSpeed.call(this, 0.5)">0.5\xD7</button>
            <button class="speed-preset active" onclick="setSpeed.call(this, 1)">1\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 2)">2\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 4)">4\xD7</button>
            <button class="speed-preset" onclick="setSpeed.call(this, 8)">8\xD7</button>
            <div class="speed-input-container">
                <span>Custom:</span>
                <input type="number" id="speedInput" value="1.0" min="0" max="50" step="0.1" onchange="setCustomSpeed()">
                <span>\xD7</span>
            </div>
        </div>
        
        <div class="status-container">
            <div id="statusDot" class="status-dot stopped"></div>
            <span id="statusText">Stopped</span>
            <span id="eventCounter">Event: 0/${this.data.events.length}</span>
        </div>
    </div>
    
    <div id="terminal"></div>
    
    <div id="eventLog" class="event-log">
        <strong>Event Log</strong> (most recent first)
    </div>
    
    <div id="eventDisplay"></div>
    
    <div class="shortcuts">
        <div class="shortcuts-title">\u2328\uFE0F Keyboard Shortcuts:</div>
        <span class="shortcut"><span class="shortcut-key">Space</span> Play/Pause</span>
        <span class="shortcut"><span class="shortcut-key">\u2190/\u2192</span> Skip -/+ 5s</span>
        <span class="shortcut"><span class="shortcut-key">\u2191/\u2193</span> Speed Up/Down</span>
        <span class="shortcut"><span class="shortcut-key">0-9</span> Jump to %</span>
    </div>
    
    <script>
        ${getPlaybackEngineSource()}
        
        // Replay data
        const replayData = ${JSON.stringify(this.data)};
        const events = replayData.events;
        const duration = replayData.duration;
        
        // Create unified playback engine
        const engine = new PlaybackEngine(events, duration, {
            speed: 1.0,
            onEvent: processEvent,
            onStateChange: updateDisplay,
            onProgress: updateDisplay
        });
        
        // DOM elements
        const terminal = document.getElementById('terminal');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const progressHandle = document.getElementById('progressHandle');
        const timeDisplay = document.getElementById('timeDisplay');
        const eventLog = document.getElementById('eventLog');
        const eventDisplay = document.getElementById('eventDisplay');
        const speedInput = document.getElementById('speedInput');
        const playBtn = document.getElementById('playBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const eventCounter = document.getElementById('eventCounter');
        
        // Initialize
        updateDisplay();
        
        function togglePlay() {
            if (engine.isPlaying()) {
                engine.pause();
            } else {
                engine.play();
            }
        }
        
        function play() {
            engine.play();
        }
        
        function pause() {
            engine.pause();
        }
        
        function stop() {
            engine.stop();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
        }
        
        function jumpToStart() {
            engine.jumpToStart();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
        }
        
        function jumpToEnd() {
            engine.jumpToEnd();
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
            
            // Process all events to current point
            for (let i = 0; i < engine.getCurrentEventIndex(); i++) {
                processEvent(events[i], engine.getState());
            }
        }
        
        function setSpeed(speed) {
            engine.setSpeed(speed);
            speedInput.value = speed.toFixed(2);
            
            // Update active preset
            document.querySelectorAll('.speed-preset').forEach(btn => {
                btn.classList.remove('active');
            });
            this.classList.add('active');
        }
        
        function setCustomSpeed() {
            const speed = Math.max(0, parseFloat(speedInput.value));
            engine.setSpeed(speed);
            
            // Update active preset
            document.querySelectorAll('.speed-preset').forEach(btn => {
                btn.classList.remove('active');
            });
        }
        
        function seekToPosition(event) {
            const rect = progressBar.getBoundingClientRect();
            const position = (event.clientX - rect.left) / rect.width;
            const percent = position * 100;
            
            engine.seekToPercent(percent);
            terminal.innerHTML = '';
            eventLog.innerHTML = '<strong>Event Log</strong> (most recent first)';
            
            // Process events up to current point
            for (let i = 0; i < engine.getCurrentEventIndex(); i++) {
                processEvent(events[i], engine.getState());
            }
        }
        
        function updateStatus(state, text) {
            statusDot.className = 'status-dot ' + state;
            statusText.textContent = text;
        }
        
        function updateDisplay() {
            const state = engine.getState();
            const progress = engine.getProgress();
            const currentTime = engine.getCurrentTime();
            
            // Update progress bar
            progressFill.style.width = progress + '%';
            progressHandle.style.left = progress + '%';
            
            // Update time display
            const currentMins = Math.floor(currentTime / 60000);
            const currentSecs = Math.floor((currentTime % 60000) / 1000);
            const totalMins = Math.floor(duration / 60000);
            const totalSecs = Math.floor((duration % 60000) / 1000);
            
            timeDisplay.textContent = 
                currentMins + ':' + currentSecs.toString().padStart(2, '0') + 
                ' / ' + 
                totalMins + ':' + totalSecs.toString().padStart(2, '0');
            
            // Update event counter
            eventCounter.textContent = 'Event: ' + state.currentEventIndex + '/' + events.length;
            
            // Update play button and status
            if (state.isPlaying) {
                updateStatus('playing', 'Playing');
                playBtn.textContent = '\u23F8 Pause';
            } else if (state.isPaused) {
                updateStatus('paused', 'Paused');
                playBtn.textContent = '\u25B6 Play';
            } else {
                updateStatus('stopped', 'Stopped');
                playBtn.textContent = '\u25B6 Play';
            }
        }
        
        function processEvent(event, state) {
            let logEntry = '<div class="event event-' + event.type + '">';
            logEntry += '[' + (event.timestamp / 1000).toFixed(2) + 's] ';
            
            switch(event.type) {
                case 'spawn':
                    logEntry += 'SPAWN: ' + event.data.command + ' ' + (event.data.args || []).join(' ');
                    break;
                    
                case 'output':
                    terminal.innerHTML += escapeHtml(event.data);
                    // Auto-scroll terminal
                    terminal.scrollTop = terminal.scrollHeight;
                    logEntry += 'OUTPUT: ' + event.data.length + ' bytes';
                    break;
                    
                case 'input':
                    logEntry += 'INPUT: ' + JSON.stringify(event.data);
                    break;
                    
                case 'key':
                    logEntry += 'KEY: ' + event.data;
                    break;
                    
                case 'resize':
                    logEntry += 'RESIZE: ' + event.data.cols + 'x' + event.data.rows;
                    break;
                    
                case 'screenshot':
                    logEntry += 'SCREENSHOT: ' + event.data.name;
                    break;
                    
                case 'expect':
                    logEntry += 'EXPECT: ' + (event.data.pattern || event.data);
                    break;
                    
                case 'exit':
                    logEntry += 'EXIT: Code ' + event.data;
                    break;
                    
                default:
                    logEntry += event.type.toUpperCase();
            }
            
            logEntry += '</div>';
            
            // Add to event log (prepend for most recent first)
            const currentLog = eventLog.innerHTML;
            const titleIndex = currentLog.indexOf('</strong>');
            if (titleIndex !== -1) {
                eventLog.innerHTML = currentLog.slice(0, titleIndex + 9) + 
                    logEntry + currentLog.slice(titleIndex + 9);
            }
            
            // Keep log size reasonable
            const logEvents = eventLog.querySelectorAll('.event');
            if (logEvents.length > 100) {
                logEvents[logEvents.length - 1].remove();
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    engine.skipBackward(5000);
                    break;
                case 'ArrowRight':
                    engine.skipForward(5000);
                    break;
                case 'ArrowUp':
                    engine.setSpeed(Math.min(50, engine.getSpeed() * 2));
                    speedInput.value = engine.getSpeed().toFixed(2);
                    break;
                case 'ArrowDown':
                    engine.setSpeed(Math.max(0.1, engine.getSpeed() / 2));
                    speedInput.value = engine.getSpeed().toFixed(2);
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    const percent = parseInt(e.key) * 10;
                    engine.seekToPercent(percent);
                    break;
            }
        });
    </script>
</body>
</html>`;
  }
  throw new Error(`Unsupported export format: ${format}`);
}
var init_export = __esm({
  "src/Replay/export.ts"() {
    "use strict";
    init_getPlaybackEngineSource();
  }
});

// src/Replay/index.ts
var Replay;
var init_Replay = __esm({
  "src/Replay/index.ts"() {
    "use strict";
    init_constructor();
    init_record();
    init_save();
    init_load();
    init_play();
    init_export();
    Replay = class {
      data;
      events;
      startTime;
      constructor() {
        constructor.call(this);
      }
      record(event) {
        return record.call(this, event);
      }
      save(path6) {
        return save.call(this, path6);
      }
      load(path6) {
        return load.call(this, path6);
      }
      async play(options) {
        return play.call(this, options);
      }
      export(format) {
        return exportReplay.call(this, format);
      }
    };
  }
});

// src/Battle/constructor.ts
function constructor2(options = {}) {
  this.options = {
    cols: 80,
    rows: 24,
    cwd: process.cwd(),
    env: process.env,
    timeout: 1e4,
    screenshotDir: "./screenshots",
    logDir: "./logs",
    verbose: false,
    ...options
  };
  this.pty = null;
  this.output = "";
  this.screenshots = [];
  this.logs = [];
  this.startTime = Date.now();
  this.replay = new Replay();
  this.replay.data.metadata.cols = this.options.cols;
  this.replay.data.metadata.rows = this.options.rows;
  this.replay.data.metadata.env = { ...this.options.env };
}
var init_constructor2 = __esm({
  "src/Battle/constructor.ts"() {
    "use strict";
    init_Replay();
  }
});

// src/PTY/Ruspty.ts
var Ruspty_exports = {};
__export(Ruspty_exports, {
  Ruspty: () => Ruspty,
  default: () => Ruspty_default
});
var Pty, Ruspty, Ruspty_default;
var init_Ruspty = __esm({
  "src/PTY/Ruspty.ts"() {
    "use strict";
    Ruspty = class {
      pty;
      fd;
      // Store file descriptor for Bun
      _killed = false;
      _pid;
      dataCallbacks = [];
      exitCallbacks = [];
      isBun = typeof Bun !== "undefined";
      constructor(command, args, options) {
        if (!Pty) {
          try {
            if (this.isBun) {
              const ruspty = require("@akaoio/ruspty/index.js");
              Pty = ruspty.Pty;
            } else {
              const ruspty = require("@akaoio/ruspty");
              Pty = ruspty.Pty;
            }
          } catch (err) {
            throw new Error(
              "@akaoio/ruspty is not installed or failed to load.\nRun: npm install @akaoio/ruspty\nNote: ARM64 support is included"
            );
          }
        }
        try {
          if (this.isBun) {
            this.pty = new Pty({
              command,
              args: args || [],
              envs: {
                // Note: raw API uses 'envs'
                ...process.env,
                ...options.env,
                TERM: options.name || "xterm-256color",
                FORCE_COLOR: "1",
                COLORTERM: "truecolor"
              },
              size: {
                rows: options.rows || 24,
                cols: options.cols || 80
              },
              onExit: (err, exitCode) => {
                this._killed = true;
                this.exitCallbacks.forEach((cb) => cb(exitCode || 0));
              }
            });
          } else {
            this.pty = new Pty({
              command,
              args: args || [],
              env: {
                // Note: wrapper API uses 'env'
                ...process.env,
                ...options.env,
                TERM: options.name || "xterm-256color",
                FORCE_COLOR: "1",
                COLORTERM: "truecolor"
              },
              size: {
                rows: options.rows || 24,
                cols: options.cols || 80
              },
              onExit: (err, exitCode) => {
                this._killed = true;
                this.exitCallbacks.forEach((cb) => cb(exitCode || 0));
              }
            });
          }
          this._pid = this.pty.pid;
          this.setupDataStream();
        } catch (err) {
          throw new Error(`Failed to create PTY: ${err.message}`);
        }
      }
      setupDataStream() {
        try {
          if (this.isBun) {
            this.fd = this.pty.takeFd();
            const fs7 = require("fs");
            const checkOutput = () => {
              if (this._killed) return;
              try {
                const buffer = Buffer.alloc(4096);
                const bytesRead = fs7.readSync(this.fd, buffer, 0, 4096, null);
                if (bytesRead > 0) {
                  const text = buffer.slice(0, bytesRead).toString();
                  this.dataCallbacks.forEach((cb) => cb(text));
                }
              } catch (err) {
                if (err.code !== "EAGAIN" && err.code !== "EWOULDBLOCK") {
                  if (err.code === "EBADF" || err.code === "EIO") {
                    this._killed = true;
                    return;
                  }
                }
              }
              if (!this._killed) {
                setTimeout(checkOutput, 10);
              }
            };
            setTimeout(checkOutput, 0);
          } else {
            const stream = this.pty.read;
            if (stream && typeof stream.on === "function") {
              stream.on("data", (data) => {
                const text = data.toString();
                this.dataCallbacks.forEach((cb) => cb(text));
              });
              stream.on("error", (err) => {
                if (err.code === "EIO") {
                  stream.emit("end");
                } else {
                  console.error("PTY stream error:", err);
                }
              });
              stream.on("end", () => {
                this._killed = true;
              });
            } else {
              throw new Error("Stream interface not available");
            }
          }
        } catch (err) {
          console.error("Failed to setup data stream:", err);
          if (!this._killed) {
            this._killed = true;
            this.exitCallbacks.forEach((cb) => cb(1));
          }
        }
      }
      onData(callback) {
        this.dataCallbacks.push(callback);
      }
      onExit(callback) {
        this.exitCallbacks.push(callback);
        if (this._killed) {
          callback(0);
        }
      }
      write(data) {
        if (!this._killed) {
          try {
            if (this.isBun && this.fd !== void 0) {
              const fs7 = require("fs");
              fs7.writeSync(this.fd, data);
            } else if (this.pty) {
              this.pty.write.write(data);
            }
          } catch (err) {
            console.error("Write error:", err);
          }
        }
      }
      resize(cols, rows) {
        if (!this._killed && this.pty && this.pty.resize) {
          try {
            this.pty.resize({ cols, rows });
          } catch (err) {
          }
        }
      }
      kill(signal) {
        if (!this._killed && this.pty) {
          try {
            if (this.pty.kill) {
              this.pty.kill();
            }
            this._killed = true;
          } catch (err) {
          }
        }
      }
      get pid() {
        return this._pid;
      }
      get killed() {
        return this._killed;
      }
    };
    Ruspty_default = Ruspty;
  }
});

// src/PTY/NodePTY.ts
var NodePTY_exports = {};
__export(NodePTY_exports, {
  NodePTY: () => NodePTY,
  default: () => NodePTY_default
});
var import_module, import_meta, NodePTY, NodePTY_default;
var init_NodePTY = __esm({
  "src/PTY/NodePTY.ts"() {
    "use strict";
    import_module = require("module");
    import_meta = {};
    NodePTY = class {
      pty;
      _killed = false;
      constructor(command, args, options) {
        let nodePty;
        if (typeof require !== "undefined") {
          try {
            nodePty = require("node-pty");
          } catch (err) {
            throw new Error("node-pty is not installed. Run: npm install node-pty");
          }
        } else if (typeof import_meta !== "undefined" && import_meta.url) {
          const requireFunc = (0, import_module.createRequire)(import_meta.url);
          try {
            nodePty = requireFunc("node-pty");
          } catch (err) {
            throw new Error("node-pty is not installed. Run: npm install node-pty");
          }
        } else {
          throw new Error("Unable to load node-pty in this environment");
        }
        this.pty = nodePty.spawn(command, args, {
          name: options.name || "xterm-256color",
          cols: options.cols || 80,
          rows: options.rows || 24,
          cwd: options.cwd || process.cwd(),
          env: { ...process.env, ...options.env, TERM: "xterm-256color" }
        });
      }
      onData(callback) {
        this.pty.onData(callback);
      }
      onExit(callback) {
        this.pty.onExit(({ exitCode }) => {
          this._killed = true;
          callback(exitCode);
        });
      }
      write(data) {
        if (!this._killed) {
          this.pty.write(data);
        }
      }
      resize(cols, rows) {
        if (!this._killed) {
          this.pty.resize(cols, rows);
        }
      }
      kill(signal) {
        if (!this._killed) {
          this.pty.kill(signal);
          this._killed = true;
        }
      }
      get pid() {
        return this.pty.pid;
      }
      get killed() {
        return this._killed;
      }
    };
    NodePTY_default = NodePTY;
  }
});

// src/PTY/index.ts
function getRuntime() {
  if (typeof Bun !== "undefined") return "bun";
  if (typeof process !== "undefined" && process.versions?.node) return "node";
  return "unknown";
}
async function createPTY(command, args, options) {
  const runtime = getRuntime();
  if (runtime === "bun") {
    const { Ruspty: Ruspty2 } = await Promise.resolve().then(() => (init_Ruspty(), Ruspty_exports));
    return new Ruspty2(command, args, options);
  } else if (runtime === "node") {
    const { NodePTY: NodePTY2 } = await Promise.resolve().then(() => (init_NodePTY(), NodePTY_exports));
    return new NodePTY2(command, args, options);
  } else {
    throw new Error(`Unsupported runtime: ${runtime}`);
  }
}
var init_PTY = __esm({
  "src/PTY/index.ts"() {
    "use strict";
  }
});

// src/Battle/spawn.ts
async function spawn(command, args = []) {
  this.log("info", `Spawning: ${command} ${args.join(" ")}`);
  if (this.pty && !this.pty.killed) {
    this.pty.kill();
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  this.output = "";
  this.replay.record({
    type: "spawn",
    timestamp: 0,
    // Will be set by record method
    data: { command, args }
  });
  this.replay.data.metadata.command = command;
  this.replay.data.metadata.args = args;
  this.pty = await createPTY(command, args, {
    name: "xterm-256color",
    cols: this.options.cols,
    rows: this.options.rows,
    cwd: this.options.cwd,
    env: {
      ...this.options.env,
      TERM: "xterm-256color",
      FORCE_COLOR: "1"
    }
  });
  this.pty.onData((data) => {
    this.output += data;
    this.replay.record({
      type: "output",
      timestamp: 0,
      data
    });
    if (this.options.verbose) {
      process.stdout.write(data);
    }
    this.log("output", data);
  });
  this.pty.onExit((exitData) => {
    this.log("info", `Process exited with code: ${exitData.exitCode}`);
    this.exitCode = exitData.exitCode;
    this.replay.record({
      type: "exit",
      timestamp: 0,
      data: exitData.exitCode
    });
  });
}
var init_spawn = __esm({
  "src/Battle/spawn.ts"() {
    "use strict";
    init_PTY();
  }
});

// src/Battle/interact.ts
async function interact(handler) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      this.log("error", "Interaction timeout");
      reject(new Error("Interaction timeout"));
    }, this.options.timeout);
    const cleanup2 = () => {
      clearTimeout(timeout);
      this.pty.onData(() => {
      });
    };
    this.pty.onData(async (data) => {
      try {
        const response = await handler(data, this.output);
        if (response === null) {
          cleanup2();
          resolve();
        } else if (response) {
          this.log("input", response);
          this.pty.write(response);
        }
      } catch (error) {
        cleanup2();
        reject(error);
      }
    });
  });
}
var init_interact = __esm({
  "src/Battle/interact.ts"() {
    "use strict";
  }
});

// src/Battle/screenshot.ts
function screenshot(name) {
  const timestamp = Date.now();
  const filename = name || `screenshot-${timestamp}.txt`;
  const filepath = import_path2.default.join(this.options.screenshotDir, filename);
  import_fs3.default.mkdirSync(this.options.screenshotDir, { recursive: true });
  const screen = parseTerminalOutput(this.output);
  import_fs3.default.writeFileSync(filepath, this.output);
  const cleanPath = filepath.replace(".txt", "-clean.txt");
  import_fs3.default.writeFileSync(cleanPath, screen.clean);
  const htmlPath = filepath.replace(".txt", ".html");
  import_fs3.default.writeFileSync(htmlPath, screen.html);
  this.replay.record({
    type: "screenshot",
    timestamp: 0,
    data: { name: filename, path: filepath }
  });
  this.screenshots.push(filepath);
  this.log("info", `Screenshot saved: ${filepath}`);
  return filepath;
}
function parseTerminalOutput(output) {
  const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
  const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace;
            white-space: pre;
            padding: 20px;
        }
        .ansi-black { color: #000; }
        .ansi-red { color: #f00; }
        .ansi-green { color: #0f0; }
        .ansi-yellow { color: #ff0; }
        .ansi-blue { color: #00f; }
        .ansi-magenta { color: #f0f; }
        .ansi-cyan { color: #0ff; }
        .ansi-white { color: #fff; }
    </style>
</head>
<body>${convertAnsiToHtml(output)}</body>
</html>`;
  return { clean, html };
}
function convertAnsiToHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\x1b\[31m/g, '<span class="ansi-red">').replace(/\x1b\[32m/g, '<span class="ansi-green">').replace(/\x1b\[33m/g, '<span class="ansi-yellow">').replace(/\x1b\[34m/g, '<span class="ansi-blue">').replace(/\x1b\[35m/g, '<span class="ansi-magenta">').replace(/\x1b\[36m/g, '<span class="ansi-cyan">').replace(/\x1b\[0m/g, "</span>").replace(/\n/g, "<br>");
}
var import_fs3, import_path2;
var init_screenshot = __esm({
  "src/Battle/screenshot.ts"() {
    "use strict";
    import_fs3 = __toESM(require("fs"), 1);
    import_path2 = __toESM(require("path"), 1);
  }
});

// src/Battle/expect.ts
async function expect(pattern, timeout = 2e3) {
  const startTime = Date.now();
  while (Date.now() - startTime < timeout) {
    const cleanOutput = this.output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
    let matches = false;
    if (typeof pattern === "string") {
      matches = cleanOutput.includes(pattern);
    } else {
      matches = pattern.test(cleanOutput);
    }
    if (matches) {
      this.replay.record({
        type: "expect",
        timestamp: 0,
        data: { pattern: pattern.toString(), matched: true }
      });
      this.log("info", `Pattern matched: ${pattern}`);
      return true;
    }
    await new Promise((resolve) => setTimeout(resolve, 50));
  }
  this.log("error", `Expected pattern not found after ${timeout}ms: ${pattern}`);
  this.screenshot("expect-failure");
  throw new Error(`Expected pattern not found: ${pattern}`);
}
var init_expect = __esm({
  "src/Battle/expect.ts"() {
    "use strict";
  }
});

// src/Battle/log.ts
function log(level, message) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}
`;
  if (!import_fs4.default.existsSync(this.options.logDir)) {
    import_fs4.default.mkdirSync(this.options.logDir, { recursive: true });
  }
  const logFile = import_path3.default.join(this.options.logDir, `battle-${this.startTime}.log`);
  import_fs4.default.appendFileSync(logFile, logEntry);
  this.logs.push(logEntry);
  if (this.options.verbose && level !== "output") {
    console.log(logEntry.trim());
  }
}
var import_fs4, import_path3;
var init_log = __esm({
  "src/Battle/log.ts"() {
    "use strict";
    import_fs4 = __toESM(require("fs"), 1);
    import_path3 = __toESM(require("path"), 1);
  }
});

// src/Battle/cleanup.ts
function cleanup() {
  if (this.pty) {
    this.log("info", "Cleaning up PTY process");
    try {
      this.pty.kill();
    } catch (error) {
      this.log("warn", `Failed to kill PTY: ${error}`);
    }
    this.pty = null;
  }
}
var init_cleanup = __esm({
  "src/Battle/cleanup.ts"() {
    "use strict";
  }
});

// src/Battle/run.ts
async function run(testFn) {
  const startTime = Date.now();
  let success = false;
  let error = null;
  try {
    this.log("info", "Starting test");
    await testFn(this);
    success = true;
    this.log("info", "Test completed successfully");
  } catch (err) {
    error = err;
    this.log("error", `Test failed: ${error.message}`);
    this.screenshot("test-failure");
  } finally {
    this.cleanup();
  }
  const duration = Date.now() - startTime;
  let replayPath;
  try {
    const replayFilename = `replay-${Date.now()}.json`;
    replayPath = import_path4.default.join(this.options.logDir || "./logs", replayFilename);
    this.replay.save(replayPath);
    this.log("info", `Replay saved: ${replayPath}`);
  } catch (e) {
    this.log("error", `Failed to save replay: ${e}`);
  }
  const result = {
    success,
    duration,
    output: this.output,
    screenshots: this.screenshots,
    logs: this.logs,
    error: error?.message || null,
    replayPath
  };
  return result;
}
var import_path4;
var init_run = __esm({
  "src/Battle/run.ts"() {
    "use strict";
    import_path4 = __toESM(require("path"), 1);
  }
});

// src/Battle/resize.ts
function resize(cols, rows) {
  if (!this.pty) {
    this.options.cols = cols;
    this.options.rows = rows;
    this.log("info", `Terminal size set to: ${cols}x${rows} (will apply on spawn)`);
    return;
  }
  this.log("info", `Resizing terminal: ${cols}x${rows}`);
  this.replay.record({
    type: "resize",
    timestamp: 0,
    data: { cols, rows }
  });
  const previousCols = this.options.cols;
  const previousRows = this.options.rows;
  this.options.cols = cols;
  this.options.rows = rows;
  this.pty.resize(cols, rows);
  setTimeout(() => {
    this.screenshot(`resize-${cols}x${rows}`);
  }, 100);
  this.log("info", `Terminal resized from ${previousCols}x${previousRows} to ${cols}x${rows}`);
}
var init_resize = __esm({
  "src/Battle/resize.ts"() {
    "use strict";
  }
});

// src/Battle/sendKey.ts
function sendKey(key) {
  if (!this.pty) {
    throw new Error("No PTY process to send keys to");
  }
  const keyMap = {
    // Arrow keys
    "up": "\x1B[A",
    "down": "\x1B[B",
    "right": "\x1B[C",
    "left": "\x1B[D",
    // Function keys
    "f1": "\x1BOP",
    "f2": "\x1BOQ",
    "f3": "\x1BOR",
    "f4": "\x1BOS",
    "f5": "\x1B[15~",
    "f6": "\x1B[17~",
    "f7": "\x1B[18~",
    "f8": "\x1B[19~",
    "f9": "\x1B[20~",
    "f10": "\x1B[21~",
    "f11": "\x1B[23~",
    "f12": "\x1B[24~",
    // Control keys
    "enter": "\r",
    "return": "\r",
    "tab": "	",
    "backspace": "\x7F",
    "delete": "\x1B[3~",
    "escape": "\x1B",
    "esc": "\x1B",
    "home": "\x1B[H",
    "end": "\x1B[F",
    "pageup": "\x1B[5~",
    "pagedown": "\x1B[6~",
    // Control combinations
    "ctrl+c": "",
    "ctrl+d": "",
    "ctrl+z": "",
    "ctrl+a": "",
    "ctrl+e": "",
    "ctrl+k": "\v",
    "ctrl+l": "\f",
    "ctrl+u": "",
    "ctrl+w": "",
    // Alt combinations
    "alt+b": "\x1Bb",
    "alt+f": "\x1Bf",
    "alt+d": "\x1Bd",
    // Special
    "space": " ",
    "clear": "\x1B[2J\x1B[H"
  };
  const sequence = keyMap[key.toLowerCase()] || key;
  this.replay.record({
    type: "key",
    timestamp: 0,
    data: key
  });
  this.replay.record({
    type: "input",
    timestamp: 0,
    data: sequence
  });
  this.log("input", `Sending key: ${key} (${sequence.replace(/\x1b/g, "^[").replace(/\r/g, "\\r").replace(/\n/g, "\\n")})`);
  this.pty.write(sequence);
}
var init_sendKey = __esm({
  "src/Battle/sendKey.ts"() {
    "use strict";
  }
});

// src/Battle/wait.ts
function wait(ms) {
  this.log("info", `Waiting ${ms}ms`);
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var init_wait = __esm({
  "src/Battle/wait.ts"() {
    "use strict";
  }
});

// src/Battle/write.ts
function write(data) {
  if (!this.pty) {
    throw new Error("No PTY process running. Call spawn() first.");
  }
  if (this.pty.killed) {
    throw new Error("PTY process has already exited");
  }
  this.log("input", `Writing: ${JSON.stringify(data)}`);
  this.replay.record({
    type: "input",
    timestamp: 0,
    data
  });
  this.pty.write(data);
}
var init_write = __esm({
  "src/Battle/write.ts"() {
    "use strict";
  }
});

// src/Battle/getCursor.ts
async function getCursor() {
  if (!this.pty) {
    throw new Error("No PTY process");
  }
  return new Promise((resolve) => {
    let response = "";
    const timeout = setTimeout(() => {
      this.log("warn", "Cursor position request timeout");
      resolve(null);
    }, 1e3);
    const handler = (data) => {
      response += data;
      const match = response.match(/\x1b\[(\d+);(\d+)R/);
      if (match) {
        clearTimeout(timeout);
        this.pty.onData(() => {
        });
        const position = {
          x: parseInt(match[2]) - 1,
          // Convert to 0-based
          y: parseInt(match[1]) - 1
        };
        this.log("info", `Cursor position: x=${position.x}, y=${position.y}`);
        resolve(position);
      }
    };
    this.pty.onData(handler);
    this.log("debug", "Requesting cursor position");
    this.pty.write("\x1B[6n");
  });
}
var init_getCursor = __esm({
  "src/Battle/getCursor.ts"() {
    "use strict";
  }
});

// src/Battle/index.ts
var Battle_exports = {};
__export(Battle_exports, {
  Battle: () => Battle,
  default: () => Battle_default
});
var Battle, Battle_default;
var init_Battle = __esm({
  "src/Battle/index.ts"() {
    "use strict";
    init_constructor2();
    init_spawn();
    init_interact();
    init_screenshot();
    init_expect();
    init_log();
    init_cleanup();
    init_run();
    init_resize();
    init_sendKey();
    init_wait();
    init_write();
    init_getCursor();
    Battle = class {
      options;
      pty;
      output;
      screenshots;
      logs;
      startTime;
      replay;
      constructor(options = {}) {
        constructor2.call(this, options);
      }
      async spawn(command, args) {
        return spawn.call(this, command, args);
      }
      interact(handler) {
        return interact.call(this, handler);
      }
      screenshot(name) {
        return screenshot.call(this, name);
      }
      async expect(pattern, timeout) {
        return expect.call(this, pattern, timeout);
      }
      log(level, message) {
        return log.call(this, level, message);
      }
      cleanup() {
        return cleanup.call(this);
      }
      async run(testFn) {
        return run.call(this, testFn);
      }
      resize(cols, rows) {
        return resize.call(this, cols, rows);
      }
      sendKey(key) {
        return sendKey.call(this, key);
      }
      write(data) {
        return write.call(this, data);
      }
      wait(ms) {
        return wait.call(this, ms);
      }
      async getCursor() {
        return getCursor.call(this);
      }
    };
    Battle_default = Battle;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Battle: () => Battle,
  Replay: () => Replay,
  Runner: () => Runner,
  Silent: () => Silent,
  test: () => test
});
module.exports = __toCommonJS(index_exports);
init_Battle();

// src/Runner/constructor.ts
function constructor3(options = {}) {
  this.suites = [];
  this.results = [];
  this.options = {
    parallel: false,
    verbose: false,
    bail: false,
    ...options
  };
}

// src/Runner/addSuite.ts
function addSuite(name, tests) {
  const suite = {
    name,
    tests
  };
  this.suites.push(suite);
}

// src/Runner/addTest.ts
function addTest(name, testCase) {
  if (this.suites.length === 0) {
    this.suites.push({
      name: "Default",
      tests: []
    });
  }
  this.suites[this.suites.length - 1].tests.push({
    name,
    ...testCase
  });
}

// src/Runner/run.ts
init_Battle();
init_colors();
async function run2() {
  console.log(color.blue("\nBattle Test Runner\n"));
  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;
  for (const suite of this.suites) {
    console.log(color.yellow(`
Suite: ${suite.name}`));
    if (suite.beforeAll) await suite.beforeAll();
    for (const test2 of suite.tests) {
      totalTests++;
      if (suite.beforeEach) await suite.beforeEach();
      const battle = new Battle({
        ...this.options,
        timeout: test2.timeout || 1e4
      });
      try {
        await battle.spawn(test2.command, test2.args);
        await battle.wait(200);
        if (test2.interactions) {
          for (const interaction of test2.interactions) {
            await battle.wait(100);
            await battle.interact(async (data, output) => {
              const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
              if (typeof interaction.expect === "string") {
                if (clean.includes(interaction.expect)) {
                  return interaction.respond;
                }
              } else if (interaction.expect.test(clean)) {
                return interaction.respond;
              }
              return null;
            });
          }
        }
        if (test2.expectations) {
          for (const expectation of test2.expectations) {
            await battle.expect(expectation);
          }
        }
        console.log(color.green(`  PASS ${test2.name}`));
        passedTests++;
      } catch (error) {
        console.log(color.red(`  FAIL ${test2.name}`));
        console.log(color.gray(`    ${error.message}`));
        failedTests++;
        if (this.options.bail) {
          break;
        }
      } finally {
        battle.cleanup();
      }
      if (suite.afterEach) await suite.afterEach();
    }
    if (suite.afterAll) await suite.afterAll();
  }
  console.log(color.blue("\nResults:"));
  console.log(`  Total: ${totalTests}`);
  console.log(color.green(`  Passed: ${passedTests}`));
  if (failedTests > 0) {
    console.log(color.red(`  Failed: ${failedTests}`));
  }
  return {
    total: totalTests,
    passed: passedTests,
    failed: failedTests
  };
}

// src/Runner/report.ts
var import_fs5 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
function report() {
  const reportPath = import_path5.default.join(this.options.logDir || "./logs", "battle-report.json");
  const report2 = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    suites: this.suites,
    results: this.results,
    summary: {
      total: this.results.length,
      passed: this.results.filter((r) => r.success).length,
      failed: this.results.filter((r) => !r.success).length
    }
  };
  import_fs5.default.mkdirSync(import_path5.default.dirname(reportPath), { recursive: true });
  import_fs5.default.writeFileSync(reportPath, JSON.stringify(report2, null, 2));
  console.log(`Report saved to: ${reportPath}`);
}

// src/Runner/index.ts
var Runner = class {
  suites;
  results;
  options;
  constructor(options = {}) {
    constructor3.call(this, options);
  }
  suite(name, tests) {
    return addSuite.call(this, name, tests);
  }
  test(name, testCase) {
    return addTest.call(this, name, testCase);
  }
  async run() {
    return run2.call(this);
  }
  report() {
    return report.call(this);
  }
};

// src/Silent/index.ts
var import_child_process = require("child_process");
var import_fs6 = __toESM(require("fs"), 1);
var Silent = class {
  logs = [];
  startTime = Date.now();
  /**
   * Run a command and capture output
   */
  exec(command, options = {}) {
    try {
      const stdout = (0, import_child_process.execSync)(command, {
        encoding: "utf8",
        ...options
      });
      this.log("info", `Executed: ${command}`);
      this.log("output", stdout);
      return {
        success: true,
        stdout,
        stderr: "",
        exitCode: 0
      };
    } catch (error) {
      this.log("error", `Failed: ${command}`);
      this.log("error", error.message);
      return {
        success: false,
        stdout: error.stdout || "",
        stderr: error.stderr || error.message,
        exitCode: error.status || 1
      };
    }
  }
  /**
   * Check if a process is running
   */
  isRunning(pattern) {
    try {
      const command = process.platform === "win32" ? `tasklist | findstr /i "${pattern}"` : `ps aux | grep -v grep | grep "${pattern}"`;
      const result = (0, import_child_process.execSync)(command, {
        encoding: "utf8",
        stdio: "pipe"
      });
      return result.trim().length > 0;
    } catch {
      return false;
    }
  }
  /**
   * Check if a port is open
   */
  isPortOpen(port, host = "localhost") {
    try {
      try {
        (0, import_child_process.execSync)("which nc", { encoding: "utf8", stdio: "pipe" });
        (0, import_child_process.execSync)(`nc -z ${host} ${port} 2>/dev/null`, {
          encoding: "utf8",
          stdio: "pipe"
        });
        return true;
      } catch {
      }
      const testCmd = process.platform === "win32" ? `powershell -Command "Test-NetConnection -ComputerName ${host} -Port ${port} -InformationLevel Quiet"` : `timeout 1 bash -c "echo > /dev/tcp/${host}/${port}" 2>/dev/null`;
      (0, import_child_process.execSync)(testCmd, { encoding: "utf8", stdio: "pipe" });
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Check if a file exists
   */
  fileExists(filepath) {
    return import_fs6.default.existsSync(filepath);
  }
  /**
   * Read file content
   */
  readFile(filepath) {
    return import_fs6.default.readFileSync(filepath, "utf8");
  }
  /**
   * Check system resources
   */
  checkResources() {
    const cpu = parseFloat(
      (0, import_child_process.execSync)("top -bn1 | grep 'Cpu(s)' | awk '{print $2}'", {
        encoding: "utf8"
      }).trim()
    );
    const mem = (0, import_child_process.execSync)(`free -m | awk 'NR==2{printf "%.1f", $3*100/$2}'`, {
      encoding: "utf8"
    });
    const disk = (0, import_child_process.execSync)("df -h / | awk 'NR==2{print $5}' | sed 's/%//'", {
      encoding: "utf8"
    });
    return {
      cpu: cpu || 0,
      memory: parseFloat(mem) || 0,
      disk: parseInt(disk) || 0
    };
  }
  /**
   * Wait for condition
   */
  async waitFor(condition, timeout = 5e3, interval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (condition()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    return false;
  }
  log(level, message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const entry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
    this.logs.push(entry);
  }
  getLogs() {
    return this.logs;
  }
};

// src/index.ts
init_Replay();
async function test(name, command, interactions, expectations) {
  const { Battle: Battle2 } = await Promise.resolve().then(() => (init_Battle(), Battle_exports));
  const battle = new Battle2({ verbose: true });
  console.log(`
Testing: ${name}`);
  const result = await battle.run(async (b) => {
    b.spawn(command);
    if (interactions) {
      for (const interaction of interactions) {
        await b.interact(async (data, output) => {
          const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
          if (typeof interaction.expect === "string") {
            if (clean.includes(interaction.expect)) {
              return interaction.respond;
            }
          } else if (interaction.expect.test(clean)) {
            return interaction.respond;
          }
          return null;
        });
      }
    }
    if (expectations) {
      for (const expectation of expectations) {
        b.expect(expectation);
      }
    }
  });
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Battle,
  Replay,
  Runner,
  Silent,
  test
});
