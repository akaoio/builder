import {
  Battle,
  color
} from "./chunk-I2WZMIYC.js";

// src/Runner/constructor.ts
function constructor(options = {}) {
  this.suites = [];
  this.results = [];
  this.options = {
    parallel: false,
    verbose: false,
    bail: false,
    ...options
  };
}

// src/Runner/addSuite.ts
function addSuite(name, tests) {
  const suite = {
    name,
    tests
  };
  this.suites.push(suite);
}

// src/Runner/addTest.ts
function addTest(name, testCase) {
  if (this.suites.length === 0) {
    this.suites.push({
      name: "Default",
      tests: []
    });
  }
  this.suites[this.suites.length - 1].tests.push({
    name,
    ...testCase
  });
}

// src/Runner/run.ts
async function run() {
  console.log(color.blue("\nBattle Test Runner\n"));
  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;
  for (const suite of this.suites) {
    console.log(color.yellow(`
Suite: ${suite.name}`));
    if (suite.beforeAll) await suite.beforeAll();
    for (const test2 of suite.tests) {
      totalTests++;
      if (suite.beforeEach) await suite.beforeEach();
      const battle = new Battle({
        ...this.options,
        timeout: test2.timeout || 1e4
      });
      try {
        await battle.spawn(test2.command, test2.args);
        await battle.wait(200);
        if (test2.interactions) {
          for (const interaction of test2.interactions) {
            await battle.wait(100);
            await battle.interact(async (data, output) => {
              const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
              if (typeof interaction.expect === "string") {
                if (clean.includes(interaction.expect)) {
                  return interaction.respond;
                }
              } else if (interaction.expect.test(clean)) {
                return interaction.respond;
              }
              return null;
            });
          }
        }
        if (test2.expectations) {
          for (const expectation of test2.expectations) {
            await battle.expect(expectation);
          }
        }
        console.log(color.green(`  PASS ${test2.name}`));
        passedTests++;
      } catch (error) {
        console.log(color.red(`  FAIL ${test2.name}`));
        console.log(color.gray(`    ${error.message}`));
        failedTests++;
        if (this.options.bail) {
          break;
        }
      } finally {
        battle.cleanup();
      }
      if (suite.afterEach) await suite.afterEach();
    }
    if (suite.afterAll) await suite.afterAll();
  }
  console.log(color.blue("\nResults:"));
  console.log(`  Total: ${totalTests}`);
  console.log(color.green(`  Passed: ${passedTests}`));
  if (failedTests > 0) {
    console.log(color.red(`  Failed: ${failedTests}`));
  }
  return {
    total: totalTests,
    passed: passedTests,
    failed: failedTests
  };
}

// src/Runner/report.ts
import fs from "fs";
import path from "path";
function report() {
  const reportPath = path.join(this.options.logDir || "./logs", "battle-report.json");
  const report2 = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    suites: this.suites,
    results: this.results,
    summary: {
      total: this.results.length,
      passed: this.results.filter((r) => r.success).length,
      failed: this.results.filter((r) => !r.success).length
    }
  };
  fs.mkdirSync(path.dirname(reportPath), { recursive: true });
  fs.writeFileSync(reportPath, JSON.stringify(report2, null, 2));
  console.log(`Report saved to: ${reportPath}`);
}

// src/Runner/index.ts
var Runner = class {
  suites;
  results;
  options;
  constructor(options = {}) {
    constructor.call(this, options);
  }
  suite(name, tests) {
    return addSuite.call(this, name, tests);
  }
  test(name, testCase) {
    return addTest.call(this, name, testCase);
  }
  async run() {
    return run.call(this);
  }
  report() {
    return report.call(this);
  }
};

// src/Silent/index.ts
import { execSync } from "child_process";
import fs2 from "fs";
var Silent = class {
  logs = [];
  startTime = Date.now();
  /**
   * Run a command and capture output
   */
  exec(command, options = {}) {
    try {
      const stdout = execSync(command, {
        encoding: "utf8",
        ...options
      });
      this.log("info", `Executed: ${command}`);
      this.log("output", stdout);
      return {
        success: true,
        stdout,
        stderr: "",
        exitCode: 0
      };
    } catch (error) {
      this.log("error", `Failed: ${command}`);
      this.log("error", error.message);
      return {
        success: false,
        stdout: error.stdout || "",
        stderr: error.stderr || error.message,
        exitCode: error.status || 1
      };
    }
  }
  /**
   * Check if a process is running
   */
  isRunning(pattern) {
    try {
      const command = process.platform === "win32" ? `tasklist | findstr /i "${pattern}"` : `ps aux | grep -v grep | grep "${pattern}"`;
      const result = execSync(command, {
        encoding: "utf8",
        stdio: "pipe"
      });
      return result.trim().length > 0;
    } catch {
      return false;
    }
  }
  /**
   * Check if a port is open
   */
  isPortOpen(port, host = "localhost") {
    try {
      try {
        execSync("which nc", { encoding: "utf8", stdio: "pipe" });
        execSync(`nc -z ${host} ${port} 2>/dev/null`, {
          encoding: "utf8",
          stdio: "pipe"
        });
        return true;
      } catch {
      }
      const testCmd = process.platform === "win32" ? `powershell -Command "Test-NetConnection -ComputerName ${host} -Port ${port} -InformationLevel Quiet"` : `timeout 1 bash -c "echo > /dev/tcp/${host}/${port}" 2>/dev/null`;
      execSync(testCmd, { encoding: "utf8", stdio: "pipe" });
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Check if a file exists
   */
  fileExists(filepath) {
    return fs2.existsSync(filepath);
  }
  /**
   * Read file content
   */
  readFile(filepath) {
    return fs2.readFileSync(filepath, "utf8");
  }
  /**
   * Check system resources
   */
  checkResources() {
    const cpu = parseFloat(
      execSync("top -bn1 | grep 'Cpu(s)' | awk '{print $2}'", {
        encoding: "utf8"
      }).trim()
    );
    const mem = execSync(`free -m | awk 'NR==2{printf "%.1f", $3*100/$2}'`, {
      encoding: "utf8"
    });
    const disk = execSync("df -h / | awk 'NR==2{print $5}' | sed 's/%//'", {
      encoding: "utf8"
    });
    return {
      cpu: cpu || 0,
      memory: parseFloat(mem) || 0,
      disk: parseInt(disk) || 0
    };
  }
  /**
   * Wait for condition
   */
  async waitFor(condition, timeout = 5e3, interval = 100) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (condition()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    return false;
  }
  log(level, message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const entry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
    this.logs.push(entry);
  }
  getLogs() {
    return this.logs;
  }
};

// src/index.ts
async function test(name, command, interactions, expectations) {
  const { Battle: Battle2 } = await import("./Battle-XOXVEIQS.js");
  const battle = new Battle2({ verbose: true });
  console.log(`
Testing: ${name}`);
  const result = await battle.run(async (b) => {
    b.spawn(command);
    if (interactions) {
      for (const interaction of interactions) {
        await b.interact(async (data, output) => {
          const clean = output.replace(/\x1b\[[0-9;]*[mGKJH]/g, "");
          if (typeof interaction.expect === "string") {
            if (clean.includes(interaction.expect)) {
              return interaction.respond;
            }
          } else if (interaction.expect.test(clean)) {
            return interaction.respond;
          }
          return null;
        });
      }
    }
    if (expectations) {
      for (const expectation of expectations) {
        b.expect(expectation);
      }
    }
  });
  return result;
}

export {
  Runner,
  Silent,
  test
};
