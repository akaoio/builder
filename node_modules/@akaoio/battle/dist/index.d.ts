interface BattleOptions {
    cols?: number;
    rows?: number;
    cwd?: string;
    env?: NodeJS.ProcessEnv;
    timeout?: number;
    screenshotDir?: string;
    logDir?: string;
    verbose?: boolean;
}
interface TestResult {
    success: boolean;
    duration: number;
    output: string;
    screenshots: string[];
    logs: string[];
    error: string | null;
    replayPath?: string;
}
type InteractionHandler = (data: string, fullOutput: string) => Promise<string | null> | string | null;
interface TestCase {
    name: string;
    command: string;
    args?: string[];
    interactions?: Array<{
        expect: string | RegExp;
        respond: string;
    }>;
    expectations?: Array<string | RegExp>;
    timeout?: number;
}
interface TestSuite {
    name: string;
    tests: TestCase[];
    beforeAll?: () => Promise<void> | void;
    afterAll?: () => Promise<void> | void;
    beforeEach?: () => Promise<void> | void;
    afterEach?: () => Promise<void> | void;
}
interface ReplayEvent {
    type: 'spawn' | 'output' | 'input' | 'resize' | 'key' | 'screenshot' | 'expect' | 'exit';
    timestamp: number;
    data: any;
}
interface ReplayData {
    version: string;
    timestamp: string;
    duration: number;
    events: ReplayEvent[];
    metadata: {
        cols: number;
        rows: number;
        command: string;
        args: string[];
        env: Record<string, string>;
    };
}

/**
 * Battle Replay System
 * Records and replays terminal sessions like StarCraft replays
 */

declare class Replay {
    data: ReplayData;
    events: ReplayEvent[];
    startTime: number;
    constructor();
    record(event: ReplayEvent): void;
    save(path: string): string;
    load(path: string): void;
    play(options?: any): Promise<void>;
    export(format: 'json' | 'html'): string;
}

/**
 * Battle Test Framework Core
 * Universal terminal testing with real PTY emulation
 */

declare class Battle {
    options: BattleOptions;
    pty: any;
    output: string;
    screenshots: string[];
    logs: string[];
    startTime: number;
    replay: Replay;
    constructor(options?: BattleOptions);
    spawn(command: string, args?: string[]): Promise<void>;
    interact(handler: InteractionHandler): Promise<void>;
    screenshot(name?: string): string;
    expect(pattern: string | RegExp, timeout?: number): Promise<boolean>;
    log(level: string, message: string): void;
    cleanup(): void;
    run(testFn: (battle: Battle) => Promise<void>): Promise<TestResult>;
    resize(cols: number, rows: number): void;
    sendKey(key: string): void;
    write(data: string): void;
    wait(ms: number): Promise<void>;
    getCursor(): Promise<{
        x: number;
        y: number;
    } | null>;
}

/**
 * Battle Test Runner
 * Executes test suites and reports results
 */

declare class Runner {
    suites: TestSuite[];
    results: any[];
    options: any;
    constructor(options?: any);
    suite(name: string, tests: TestCase[]): void;
    test(name: string, testCase: TestCase): void;
    run(): Promise<{
        total: number;
        passed: number;
        failed: number;
    }>;
    report(): void;
}

/**
 * Silent - Testing for non-interactive/system apps
 * Tests commands that don't need PTY emulation
 */
declare class Silent {
    private logs;
    private startTime;
    /**
     * Run a command and capture output
     */
    exec(command: string, options?: any): {
        success: boolean;
        stdout: string;
        stderr: string;
        exitCode: number | null;
    };
    /**
     * Check if a process is running
     */
    isRunning(pattern: string): boolean;
    /**
     * Check if a port is open
     */
    isPortOpen(port: number, host?: string): boolean;
    /**
     * Check if a file exists
     */
    fileExists(filepath: string): boolean;
    /**
     * Read file content
     */
    readFile(filepath: string): string;
    /**
     * Check system resources
     */
    checkResources(): {
        cpu: number;
        memory: number;
        disk: number;
    };
    /**
     * Wait for condition
     */
    waitFor(condition: () => boolean, timeout?: number, interval?: number): Promise<boolean>;
    private log;
    getLogs(): string[];
}

declare function test(name: string, command: string, interactions?: Array<{
    expect: string | RegExp;
    respond: string;
}>, expectations?: Array<string | RegExp>): Promise<TestResult>;

export { Battle, type BattleOptions, type InteractionHandler, Replay, type ReplayData, type ReplayEvent, Runner, Silent, type TestCase, type TestResult, type TestSuite, test };
