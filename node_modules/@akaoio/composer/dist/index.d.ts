interface DataItem {
    [key: string]: any;
}
interface DataCollection {
    [key: string]: DataItem | DataItem[];
}
interface TemplateVariable {
    path: string[];
    original: string;
    value?: any;
}
interface RenderContext {
    data: Record<string, any>;
    variables?: Record<string, any>;
    functions?: Record<string, Function>;
}
interface ImportConfig {
    source: string;
    alias?: string;
    select?: string;
    type?: 'inline' | 'frontmatter' | 'block';
}
interface ImportResult {
    source: string;
    data: any;
    alias?: string;
}
interface ImportContext {
    loadedFiles: Map<string, any>;
    importChain: string[];
    baseDir: string;
}

interface SourceConfig {
    pattern: string | string[];
    exclude?: string[];
    parser?: 'yaml' | 'json' | 'markdown' | 'handlebars' | string;
    namespace?: string;
    transform?: (content: any, file: {
        path: string;
        name: string;
    }) => any;
}
interface TaskConfig {
    name: string;
    input: string | string[];
    processor: string;
    output?: string | string[];
    options?: Record<string, any>;
    condition?: (context: any) => boolean;
}
interface OutputConfig {
    target: string | string[] | {
        pattern: string;
        forEach?: string;
        contentTemplate?: string;
    };
    format: 'markdown' | 'json' | 'html' | 'yaml' | string;
    processor: string;
    template?: string;
    data?: string;
    options?: Record<string, any>;
}
interface WatchConfig {
    patterns: string[];
    ignore?: string[];
    debounce?: number;
    reload?: boolean;
}
interface ComposerConfig {
    sources: Record<string, SourceConfig>;
    build: {
        tasks: TaskConfig[];
        parallel?: boolean;
        bail?: boolean;
    };
    outputs: OutputConfig[];
    plugins?: string[];
    watch?: WatchConfig;
    options?: {
        baseDir?: string;
        cacheDir?: string;
        verbose?: boolean;
        silent?: boolean;
        [key: string]: any;
    };
}
interface BuildContext {
    sources: Record<string, any>;
    data: Record<string, any>;
    variables: Record<string, any>;
    files: Map<string, any>;
    config: ComposerConfig;
}
interface Processor {
    name: string;
    process: (input: any, options: any, context: BuildContext) => Promise<any>;
}
interface Plugin {
    name: string;
    setup?: (config: ComposerConfig) => void;
    processors?: Processor[];
    hooks?: {
        beforeBuild?: (context: BuildContext) => Promise<void>;
        afterBuild?: (context: BuildContext, outputs: Map<string, string>) => Promise<void>;
        [key: string]: any;
    };
}

interface ComposerOptions {
    dataPath?: string;
    templatesPath?: string;
    outputPath?: string;
    watch?: boolean;
    debounceMs?: number;
}
declare class Composer {
    options: ComposerOptions;
    context: RenderContext;
    watcher: any;
    customProcessors?: Processor[];
    constructor(options?: ComposerOptions);
    loadData(): Promise<void>;
    render(): Promise<Map<string, string>>;
    renderWithConfig(configPath?: string): Promise<Map<string, string>>;
    registerProcessor(processor: Processor): void;
    watch(callback?: (outputs: Map<string, string>) => void): void;
    stop(): void;
}

declare class Template {
    template: string;
    context?: RenderContext;
    constructor(template: string, context?: RenderContext);
    render(context?: RenderContext): string;
    parseVariables(template: string): TemplateVariable[];
    resolveVariable(variable: TemplateVariable): string;
    renderWithLoops(template: string, context?: any): string;
    resolveData(path: string[]): any;
}

declare class ConfigLoader {
    configPath?: string;
    config?: ComposerConfig;
    constructor(configPath?: string);
    loadConfig(configPath?: string): Promise<ComposerConfig>;
    resolveConfig(config: Partial<ComposerConfig>, baseDir?: string): ComposerConfig;
    validateConfig(config: ComposerConfig): void;
    findConfigFile(): string | undefined;
}

declare class BuildPipeline {
    config: ComposerConfig;
    context: BuildContext;
    processors: Map<string, Processor>;
    constructor(config: ComposerConfig);
    execute(): Promise<Map<string, string>>;
    executeTask(task: any): Promise<void>;
    loadSources(): Promise<void>;
    processOutputs(): Promise<Map<string, string>>;
    resolveInput(input: string | string[]): any;
    resolveRegexPattern(pattern: string | RegExp, baseDir: string): Promise<string[]>;
    resolveOutputTargets(target: any, result: any): Promise<Array<{
        path: string;
        content?: string;
        options?: any;
    }>>;
    formatOutput(content: string, format: string, options?: any): Promise<string>;
    registerProcessor(processor: Processor): void;
    formatAsMarkdown(content: any, options?: any): Promise<string>;
    formatAsHtml(content: string, options?: any): Promise<string>;
    formatAsJson(content: string, options?: any): Promise<string>;
    formatAsYaml(content: string, options: any): Promise<string>;
    formatAsXml(content: any, options?: any): Promise<string>;
    formatAsCsv(content: any, options?: any): Promise<string>;
    objectToXml(obj: any, rootElement: string): Promise<string>;
    resolveComplexTarget(targetConfig: any, result: any): Promise<Array<{
        path: string;
        content?: string;
        options?: any;
    }>>;
    generateDynamicTargets(targetConfig: any, result: any): Promise<Array<{
        path: string;
        content?: string;
        options?: any;
    }>>;
    getDataForPattern(pattern: string, result: any): any;
    evaluateCondition(condition: string | Function, result: any): Promise<boolean>;
    convertMarkdownToHtml(markdown: string): Promise<string>;
    renderTemplate(template: string, context: any): Promise<string>;
    walkDir(dirPath: string, callback: (filePath: string) => void): Promise<void>;
}

declare class ImportResolver {
    context: ImportContext;
    constructor();
    resolveImport(importConfig: ImportConfig, baseDir?: string): Promise<ImportResult>;
    parseImports(content: string, format: 'yaml' | 'json' | 'markdown'): ImportConfig[];
    loadImportedFile(filePath: string): Promise<any>;
    processImportChain(filePath: string): Promise<any>;
    selectFromData(data: any, selector: string): any;
}

/**
 * Platform abstraction types for Composer
 * Cross-platform compatibility interfaces
 */
/**
 * Platform capabilities detection
 */
interface PlatformCapabilities {
    platform: NodeJS.Platform;
    runtime: 'bun' | 'node' | 'deno';
    hasBun: boolean;
    hasNode: boolean;
    hasDeno: boolean;
    hasSymlinks: boolean;
    hasHardlinks: boolean;
    caseSensitiveFS: boolean;
    hasNativeWatch: boolean;
    hasFastGlob: boolean;
    isRoot: boolean;
    canSudo: boolean;
    hasShell: boolean;
    arch: string;
    hasNpm: boolean;
    hasPnpm: boolean;
    hasYarn: boolean;
}
/**
 * Platform-specific paths following OS conventions
 */
interface PlatformPaths {
    home: string;
    userData: string;
    appData: string;
    documents: string;
    downloads: string;
    desktop: string;
    config: string;
    cache: string;
    temp: string;
    logs: string;
    system: string;
    bin: string;
    lib: string;
    sep: string;
    delimiter: string;
}
/**
 * Main strategy interface for platform operations
 */
interface PlatformStrategy {
    getName(): string;
    getCapabilities(): PlatformCapabilities;
    getPaths(): PlatformPaths;
    normalizePath(filePath: string): string;
    isAbsolutePath(filePath: string): boolean;
    createDirectory(dirPath: string): Promise<void>;
    resolveDataDir(appName: string): string;
    resolveConfigDir(appName: string): string;
    resolveCacheDir(appName: string): string;
    resolveTempDir(appName: string): string;
    getEnvVars(): Record<string, string>;
    executeCommand(command: string): Promise<string>;
    getWatcherType(): 'chokidar' | 'fs.watch' | 'polling';
    getGlobType(): 'fast-glob' | 'glob' | 'manual';
}

/**
 * Platform Detection and Abstraction for Composer
 * Cross-platform file operations, path resolution, and environment detection
 */

declare class Platform {
    private static instance;
    private strategy;
    constructor();
    /**
     * Singleton pattern - ensures one platform strategy per process
     */
    static getInstance(): Platform;
    /**
     * Detects runtime and platform, creates appropriate strategy
     */
    private detectAndCreateStrategy;
    /**
     * Get the current platform strategy
     */
    getStrategy(): PlatformStrategy;
    /**
     * Get platform capabilities
     */
    getCapabilities(): PlatformCapabilities;
    /**
     * Get platform-specific paths
     */
    getPaths(): PlatformPaths;
    /**
     * Get platform name
     */
    getName(): string;
    /**
     * Detect optimal file watching strategy
     */
    getWatcherType(): 'chokidar' | 'fs.watch' | 'polling';
    /**
     * Get optimal glob library
     */
    getGlobType(): 'fast-glob' | 'glob' | 'manual';
    /**
     * Resolve data directory with platform conventions
     */
    resolveDataDir(appName?: string): string;
    /**
     * Resolve config directory with platform conventions
     */
    resolveConfigDir(appName?: string): string;
    /**
     * Resolve cache directory with platform conventions
     */
    resolveCacheDir(appName?: string): string;
    /**
     * Resolve temp directory with platform conventions
     */
    resolveTempDir(appName?: string): string;
    /**
     * Get environment variables with platform-specific handling
     */
    getEnvVars(): Record<string, string>;
    /**
     * Normalize file paths for platform
     */
    normalizePath(filePath: string): string;
    /**
     * Check if path is absolute
     */
    isAbsolutePath(filePath: string): boolean;
    /**
     * Create directory with platform-appropriate permissions
     */
    createDirectory(dirPath: string): Promise<void>;
    /**
     * Execute shell command with platform handling
     */
    executeCommand(command: string): Promise<string>;
    /**
     * Force a specific strategy (useful for testing)
     */
    setStrategy(strategy: PlatformStrategy): void;
}

export { type BuildContext, BuildPipeline, Composer, type ComposerConfig, ConfigLoader, type DataCollection, type DataItem, type ImportConfig, type ImportContext, ImportResolver, type ImportResult, type OutputConfig, Platform, type PlatformCapabilities, type PlatformPaths, type PlatformStrategy, type Plugin, type Processor, type RenderContext, type SourceConfig, type TaskConfig, Template, type TemplateVariable, type WatchConfig };
