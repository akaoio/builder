var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/Composer/constructor.ts
function constructor(options = {}) {
  this.options = {
    dataPath: options.dataPath || "./data",
    templatesPath: options.templatesPath || "./templates",
    outputPath: options.outputPath || "./output",
    watch: options.watch || false,
    debounceMs: options.debounceMs || 1e3,
    ...options
  };
  this.context = {
    data: {},
    variables: {},
    functions: {}
  };
  this.watcher = null;
  this.customProcessors = [];
}

// src/Composer/load/data.ts
import { promises as fs } from "fs";
import path from "path";
import yaml from "js-yaml";
async function data() {
  const dataPath = this.options.dataPath;
  if (!await fs.access(dataPath).then(() => true).catch(() => false)) {
    console.log(`Data directory not found: ${dataPath}`);
    return;
  }
  this.context.data = {};
  await loadDirectory(dataPath, this.context.data, dataPath);
}
async function loadDirectory(dirPath, data2, basePath) {
  const entries = await fs.readdir(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      const relativePath = path.relative(basePath, fullPath);
      const segments = relativePath.split(path.sep);
      let target = data2;
      for (const segment of segments) {
        if (!target[segment]) target[segment] = {};
        target = target[segment];
      }
      await loadDirectory(fullPath, target, basePath);
    } else if (isDataFile(entry.name)) {
      const content = await fs.readFile(fullPath, "utf-8");
      const ext = path.extname(entry.name).toLowerCase();
      const name = path.basename(entry.name, ext);
      let parsedData;
      switch (ext) {
        case ".json":
          parsedData = JSON.parse(content);
          break;
        case ".yaml":
        case ".yml":
          parsedData = yaml.load(content);
          break;
        case ".md":
        case ".markdown":
          const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
          if (frontmatterMatch) {
            const frontmatter = yaml.load(frontmatterMatch[1]) || {};
            parsedData = {
              ...typeof frontmatter === "object" && frontmatter !== null ? frontmatter : {},
              content: frontmatterMatch[2].trim()
            };
          } else {
            parsedData = { content: content.trim() };
          }
          break;
        case ".txt":
          parsedData = { content: content.trim() };
          break;
        default:
          parsedData = { content };
      }
      parsedData._meta = {
        file: fullPath,
        name,
        ext,
        relativePath: path.relative(basePath, fullPath)
      };
      data2[name] = parsedData;
    }
  }
}
function isDataFile(filename) {
  const ext = path.extname(filename).toLowerCase();
  return [".json", ".yaml", ".yml", ".md", ".markdown", ".txt"].includes(ext);
}

// src/Composer/render.ts
import { promises as fs2 } from "fs";
import path2 from "path";

// src/Template/render.ts
function render(contextOrTemplate) {
  let templateContent = this.template;
  if (typeof contextOrTemplate === "string") {
    templateContent = contextOrTemplate;
  } else if (contextOrTemplate && typeof contextOrTemplate === "object") {
    this.context = contextOrTemplate;
  }
  let rendered = this.renderWithLoops(templateContent, this.context);
  const variables = this.parseVariables(rendered);
  for (const variable of variables) {
    const value = this.resolveVariable(variable);
    rendered = rendered.replace(variable.original, value);
  }
  return rendered;
}

// src/Template/parseVariables.ts
function parseVariables(template) {
  const variables = [];
  const variableRegex = /\{\{([^}]+)\}\}/g;
  let match;
  while ((match = variableRegex.exec(template)) !== null) {
    const pathString = match[1].trim();
    if (!pathString) {
      continue;
    }
    if (!/^[a-zA-Z0-9_.\[\]\-]+$/.test(pathString)) {
      continue;
    }
    const path12 = [];
    let current = "";
    let inBrackets = false;
    for (let i = 0; i < pathString.length; i++) {
      const char = pathString[i];
      if (char === "[") {
        if (current) {
          path12.push(current);
          current = "";
        }
        inBrackets = true;
      } else if (char === "]") {
        if (inBrackets && current) {
          path12.push(current);
          current = "";
        }
        inBrackets = false;
      } else if (char === "." && !inBrackets) {
        if (current) {
          path12.push(current);
          current = "";
        }
      } else {
        current += char;
      }
    }
    if (current) {
      path12.push(current);
    }
    if (path12.length > 0) {
      variables.push({
        path: path12,
        original: match[0],
        value: void 0
        // Will be resolved at render time
      });
    }
  }
  return variables;
}

// src/Template/resolveVariable.ts
function resolveVariable(variable) {
  const resolveFromRoot = (path12, root) => {
    let current = root;
    for (const segment of path12) {
      if (current == null) {
        return null;
      }
      if (Array.isArray(current) && /^-?\d+$/.test(segment)) {
        const index = parseInt(segment, 10);
        const actualIndex = index < 0 ? current.length + index : index;
        if (actualIndex >= 0 && actualIndex < current.length) {
          current = current[actualIndex];
        } else {
          return null;
        }
      } else if (current && typeof current === "object" && segment in current) {
        current = current[segment];
      } else {
        return null;
      }
    }
    return current;
  };
  let result = resolveFromRoot(variable.path, this.context?.data);
  if (result == null && this.context) {
    result = resolveFromRoot(variable.path, this.context);
  }
  if (result == null) {
    return "";
  }
  if (typeof result === "function") {
    try {
      return String(result());
    } catch (error) {
      console.warn(`Error calling function ${variable.path.join(".")}: ${error}`);
      return "";
    }
  }
  if (typeof result === "object" && result !== null && !Array.isArray(result)) {
    if (result instanceof Promise || result.then && typeof result.then === "function") {
      return "";
    }
    const lastSegment = variable.path[variable.path.length - 1];
    if (lastSegment in result) {
      return String(result[lastSegment]);
    }
    const contentKeys = ["content", "value", "text", "data"];
    for (const key of contentKeys) {
      if (key in result) {
        return String(result[key]);
      }
    }
    return "";
  }
  return String(result);
}

// src/Template/resolveFromContext.ts
function resolveFromContext(path12, data2) {
  let current = data2;
  for (const key of path12) {
    if (current && typeof current === "object") {
      current = current[key];
    } else {
      return void 0;
    }
  }
  return current;
}

// src/Template/renderWithLoops.ts
function renderWithLoops(template, context) {
  const ctx = context || this.context;
  const findMatchingEnd = (str, startPos) => {
    let depth = 1;
    let pos = startPos;
    while (depth > 0 && pos < str.length) {
      const nextEach = str.indexOf("{{#each", pos);
      const nextEnd = str.indexOf("{{/each}}", pos);
      if (nextEnd === -1) {
        return -1;
      }
      if (nextEach !== -1 && nextEach < nextEnd) {
        depth++;
        pos = nextEach + 7;
      } else {
        depth--;
        if (depth === 0) {
          return nextEnd;
        }
        pos = nextEnd + 9;
      }
    }
    return -1;
  };
  let result = template;
  let processed = true;
  while (processed) {
    processed = false;
    const eachStart = result.indexOf("{{#each");
    if (eachStart === -1) break;
    const eachEndTag = result.indexOf("}}", eachStart);
    if (eachEndTag === -1) break;
    const arrayPath = result.substring(eachStart + 7, eachEndTag).trim();
    const contentStart = eachEndTag + 2;
    const endPos = findMatchingEnd(result, contentStart);
    if (endPos === -1) break;
    const loopContent = result.substring(contentStart, endPos);
    const fullMatch = result.substring(eachStart, endPos + 9);
    const array = resolveFromContext(arrayPath.split("."), ctx);
    if (Array.isArray(array)) {
      const renderedItems = array.map((item, index) => {
        const itemContext = {
          ...ctx,
          // Use the passed context
          item,
          index,
          this: item,
          // Support {{this}} for current item
          "@index": index,
          "@first": index === 0,
          "@last": index === array.length - 1
        };
        if (typeof item === "object" && item !== null && !Array.isArray(item)) {
          Object.keys(item).forEach((key) => {
            itemContext[key] = item[key];
          });
        }
        let processed2 = this.renderWithLoops(loopContent, itemContext);
        const variables = this.parseVariables(processed2);
        for (const variable of variables) {
          const value = resolveFromContext(variable.path, itemContext);
          if (value !== void 0) {
            processed2 = processed2.replace(variable.original, String(value));
          }
        }
        return processed2;
      });
      result = result.substring(0, eachStart) + renderedItems.join("") + result.substring(endPos + 9);
      processed = true;
    } else {
      result = result.substring(0, eachStart) + result.substring(endPos + 9);
      processed = true;
    }
  }
  let hasIfBlocks = true;
  while (hasIfBlocks) {
    hasIfBlocks = false;
    const ifRegex = /\{\{#if\s+([^}]+)\}\}([\s\S]*?)(?:\{\{else\}\}([\s\S]*?))?\{\{\/if\}\}/;
    const match = ifRegex.exec(result);
    if (match) {
      hasIfBlocks = true;
      const conditionPath = match[1].trim();
      const ifContent = match[2];
      const elseContent = match[3] || "";
      const fullMatch = match[0];
      const conditionValue = resolveFromContext(conditionPath.split("."), ctx);
      const isTruthy = conditionValue && conditionValue !== "" && conditionValue !== "0" && conditionValue !== false;
      if (isTruthy) {
        result = result.replace(fullMatch, ifContent);
      } else {
        result = result.replace(fullMatch, elseContent);
      }
    }
  }
  return result;
}

// src/Template/resolveData.ts
function resolveData(path12) {
  const resolveFromRoot = (segments, root) => {
    let current = root;
    for (const segment of segments) {
      if (current == null) {
        return null;
      }
      if (Array.isArray(current) && /^-?\d+$/.test(segment)) {
        const index = parseInt(segment, 10);
        const actualIndex = index < 0 ? current.length + index : index;
        if (actualIndex >= 0 && actualIndex < current.length) {
          current = current[actualIndex];
        } else {
          return null;
        }
      } else if (current && typeof current === "object" && segment in current) {
        current = current[segment];
      } else {
        return null;
      }
    }
    return current;
  };
  let result = resolveFromRoot(path12, this.context?.data);
  if (result == null && this.context) {
    result = resolveFromRoot(path12, this.context);
  }
  return result;
}

// src/Template/index.ts
var Template = class {
  template;
  context;
  constructor(template, context) {
    this.template = template;
    this.context = context;
  }
  render(context) {
    if (context) {
      this.context = context;
    }
    return render.call(this, this.template);
  }
  parseVariables(template) {
    return parseVariables.call(this, template);
  }
  resolveVariable(variable) {
    return resolveVariable.call(this, variable);
  }
  renderWithLoops(template, context) {
    return renderWithLoops.call(this, template, context);
  }
  resolveData(path12) {
    return resolveData.call(this, path12);
  }
};

// src/Composer/render.ts
async function render2() {
  const outputs = /* @__PURE__ */ new Map();
  await this.loadData();
  const templatesPath = this.options.templatesPath;
  if (!await fs2.access(templatesPath).then(() => true).catch(() => false)) {
    console.log(`Templates directory not found: ${templatesPath}`);
    return outputs;
  }
  const templateFiles = await getTemplateFiles(templatesPath);
  for (const templateFile of templateFiles) {
    const templateContent = await fs2.readFile(templateFile, "utf-8");
    const template = new Template(templateContent, this.context);
    const rendered = template.render();
    const relativePath = path2.relative(templatesPath, templateFile);
    const outputName = path2.basename(relativePath, path2.extname(relativePath));
    outputs.set(outputName, rendered);
    if (this.options.outputPath) {
      const outputPath = path2.join(this.options.outputPath, `${outputName}.md`);
      await fs2.mkdir(path2.dirname(outputPath), { recursive: true });
      await fs2.writeFile(outputPath, rendered, "utf-8");
      console.log(`Generated: ${outputPath}`);
    }
  }
  return outputs;
}
async function getTemplateFiles(dir) {
  const files = [];
  const entries = await fs2.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path2.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...await getTemplateFiles(fullPath));
    } else if (isTemplateFile(entry.name)) {
      files.push(fullPath);
    }
  }
  return files;
}
function isTemplateFile(filename) {
  const ext = path2.extname(filename).toLowerCase();
  return [".md", ".html", ".txt", ".yaml", ".json"].includes(ext);
}

// src/BuildPipeline/constructor.ts
function constructor2(config2) {
  this.config = config2;
  this.context = {
    sources: {},
    data: {},
    variables: {},
    files: /* @__PURE__ */ new Map(),
    config: config2
  };
  this.processors = /* @__PURE__ */ new Map();
  registerBuiltinProcessors.call(this);
}
function registerBuiltinProcessors() {
  this.processors.set("particle-loader", {
    name: "particle-loader",
    process: async (input) => {
      return input;
    }
  });
  this.processors.set("component-loader", {
    name: "component-loader",
    process: async (input) => {
      return input;
    }
  });
  this.processors.set("document-composer", {
    name: "document-composer",
    process: async (input, options, context) => {
      return input;
    }
  });
  this.processors.set("markdown-renderer", {
    name: "markdown-renderer",
    process: async (input) => {
      return typeof input === "string" ? input : JSON.stringify(input);
    }
  });
  this.processors.set("json-bundler", {
    name: "json-bundler",
    process: async (input) => {
      return JSON.stringify(input, null, 2);
    }
  });
  this.processors.set("test-processor", {
    name: "test-processor",
    process: async (input) => {
      return { processed: input, timestamp: Date.now() };
    }
  });
  this.processors.set("markdown-processor", {
    name: "markdown-processor",
    process: async (input) => {
      return typeof input === "string" ? input : JSON.stringify(input);
    }
  });
}

// src/BuildPipeline/execute.ts
async function execute() {
  if (!this.config.options?.silent) {
    console.log("\u{1F3D7}\uFE0F Starting build pipeline...");
  }
  await this.loadSources();
  for (const task of this.config.build.tasks) {
    await this.executeTask(task);
  }
  if (!this.config.options?.silent) {
    console.log("\u{1F4E6} Processing outputs...");
  }
  const outputs = await this.processOutputs();
  if (!this.config.options?.silent) {
    console.log(`\u2705 Build completed. Generated ${outputs.size} outputs.`);
  }
  return outputs;
}

// src/BuildPipeline/executeTask.ts
async function executeTask(task) {
  if (task.condition && !task.condition(this.context)) {
    return;
  }
  const input = this.resolveInput(task.input);
  const processor2 = this.processors.get(task.processor);
  if (!processor2) {
    throw new Error(`Processor '${task.processor}' not found for task '${task.name}'`);
  }
  const result = await processor2.process(input, task.options || {}, this.context);
  if (task.name) {
    this.context.variables[task.name] = result;
  }
  if (task.output) {
    this.context.variables[`${task.name}_output`] = result;
  }
}

// src/BuildPipeline/loadSources.ts
import { promises as fs4 } from "fs";
import path6 from "path";
import yaml4 from "js-yaml";
import { glob } from "glob";

// src/ImportResolver/resolveImport.ts
import path3 from "path";
async function resolveImport(importConfig, baseDir) {
  this.context.importChain = [];
  const resolveDir = baseDir || this.context.baseDir;
  const importPath = path3.isAbsolute(importConfig.source) ? importConfig.source : path3.resolve(resolveDir, importConfig.source);
  const importedData = await this.loadImportedFile(importPath);
  let selectedData = importedData;
  if (importConfig.select) {
    selectedData = this.selectFromData(importedData, importConfig.select);
  }
  const result = {
    source: importPath,
    data: selectedData,
    alias: importConfig.alias
  };
  return result;
}

// src/ImportResolver/parseImports.ts
import yaml2 from "js-yaml";
function parseImports(content, format) {
  const imports = [];
  switch (format) {
    case "yaml":
      imports.push(...parseYamlImports.call(this, content));
      break;
    case "json":
      imports.push(...parseJsonImports.call(this, content));
      break;
    case "markdown":
      imports.push(...parseMarkdownImports.call(this, content));
      break;
  }
  return imports;
}
function parseYamlImports(content) {
  try {
    let findImports2 = function(obj, currentPath = []) {
      if (!obj || typeof obj !== "object") return;
      if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
          if (item && typeof item === "object" && item.import) {
            imports.push(normalizeImportConfig.call(this, item.import));
          } else {
            findImports2(item, [...currentPath, String(index)]);
          }
        });
      } else {
        Object.entries(obj).forEach(([key, value]) => {
          if (key === "import" && typeof value === "string") {
            imports.push(normalizeImportConfig.call(this, value));
          } else if (key === "imports" && Array.isArray(value)) {
            value.forEach((imp) => {
              imports.push(normalizeImportConfig.call(this, imp));
            });
          } else {
            findImports2(value, [...currentPath, key]);
          }
        });
      }
    };
    var findImports = findImports2;
    const data2 = yaml2.load(content);
    const imports = [];
    findImports2(data2);
    return imports;
  } catch (error) {
    return [];
  }
}
function parseJsonImports(content) {
  try {
    let findImports2 = function(obj, currentPath = []) {
      if (!obj || typeof obj !== "object") return;
      if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
          if (typeof item === "string" && item.startsWith("import:")) {
            imports.push(normalizeImportConfig.call(this, item.substring(7)));
          } else if (item && typeof item === "object" && item.import) {
            imports.push(normalizeImportConfig.call(this, item.import));
          } else {
            findImports2(item, [...currentPath, String(index)]);
          }
        });
      } else {
        Object.entries(obj).forEach(([key, value]) => {
          if (key === "import" && typeof value === "string") {
            imports.push(normalizeImportConfig.call(this, value));
          } else if (key === "imports" && Array.isArray(value)) {
            value.forEach((imp) => {
              imports.push(normalizeImportConfig.call(this, imp));
            });
          } else if (typeof value === "string" && value.startsWith("import:")) {
            imports.push(normalizeImportConfig.call(this, value.substring(7)));
          } else {
            findImports2(value, [...currentPath, key]);
          }
        });
      }
    };
    var findImports = findImports2;
    const data2 = JSON.parse(content);
    const imports = [];
    findImports2(data2);
    return imports;
  } catch (error) {
    return [];
  }
}
function parseMarkdownImports(content) {
  const imports = [];
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (frontmatterMatch) {
    try {
      const frontmatter = yaml2.load(frontmatterMatch[1]);
      if (frontmatter?.import) {
        imports.push(normalizeImportConfig.call(this, frontmatter.import));
      }
      if (frontmatter?.imports && Array.isArray(frontmatter.imports)) {
        for (const imp of frontmatter.imports) {
          imports.push(normalizeImportConfig.call(this, imp));
        }
      }
    } catch (error) {
    }
  }
  const inlineImportRegex = /\{\{import:\s*([^}]+)\}\}/g;
  let match;
  while ((match = inlineImportRegex.exec(content)) !== null) {
    imports.push({
      source: match[1].trim(),
      type: "inline"
    });
  }
  return imports;
}
function normalizeImportConfig(imp) {
  if (typeof imp === "string") {
    return { source: imp };
  }
  if (typeof imp === "object" && imp.source) {
    return imp;
  }
  throw new Error(`Invalid import configuration: ${JSON.stringify(imp)}`);
}

// src/ImportResolver/loadImportedFile.ts
import { promises as fs3 } from "fs";
import path4 from "path";
import yaml3 from "js-yaml";
async function loadImportedFile(filePath) {
  const normalizedPath = path4.resolve(filePath);
  if (this.context.loadedFiles.has(normalizedPath)) {
    return this.context.loadedFiles.get(normalizedPath);
  }
  if (this.context.importChain && this.context.importChain.includes(normalizedPath)) {
    throw new Error(`Circular import detected: ${normalizedPath}`);
  }
  if (this.context.importChain) {
    this.context.importChain.push(normalizedPath);
  }
  try {
    await fs3.access(normalizedPath);
  } catch (error) {
    throw new Error(`Import file not found: ${normalizedPath}`);
  }
  const content = await fs3.readFile(normalizedPath, "utf-8");
  const ext = path4.extname(normalizedPath).toLowerCase();
  let data2;
  switch (ext) {
    case ".json":
      data2 = JSON.parse(content);
      break;
    case ".yaml":
    case ".yml":
      data2 = yaml3.load(content);
      break;
    case ".md":
    case ".markdown":
      data2 = parseMarkdownFile.call(this, content, normalizedPath);
      break;
    default:
      data2 = { content, filePath: normalizedPath };
  }
  if (data2 && typeof data2 === "object") {
    data2 = await resolveImportsInData.call(this, data2, path4.dirname(normalizedPath));
  }
  if (this.context.importChain) {
    this.context.importChain.pop();
  }
  this.context.loadedFiles.set(normalizedPath, data2);
  return data2;
}
function parseMarkdownFile(content, filePath) {
  const result = {
    content,
    filePath,
    name: path4.basename(filePath, path4.extname(filePath))
  };
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (frontmatterMatch) {
    try {
      const frontmatter = yaml3.load(frontmatterMatch[1]);
      const body = frontmatterMatch[2];
      Object.assign(result, frontmatter);
      result.content = body;
      result.raw = content;
    } catch (error) {
    }
  }
  return result;
}
async function resolveImportsInData(data2, baseDir) {
  if (typeof data2 === "string" && data2.startsWith("import:")) {
    const importPath = path4.resolve(baseDir, data2.substring(7));
    return await this.loadImportedFile(importPath);
  }
  if (!data2 || typeof data2 !== "object") return data2;
  if (Array.isArray(data2)) {
    const resolved = [];
    for (const item of data2) {
      if (typeof item === "string" && item.startsWith("import:")) {
        const importPath = path4.resolve(baseDir, item.substring(7));
        const importedData = await this.loadImportedFile(importPath);
        resolved.push(importedData);
      } else if (item && typeof item === "object" && item.import) {
        const importPath = path4.resolve(baseDir, item.import);
        const importedData = await this.loadImportedFile(importPath);
        resolved.push(importedData);
      } else {
        resolved.push(await resolveImportsInData.call(this, item, baseDir));
      }
    }
    return resolved;
  } else {
    const resolved = {};
    for (const [key, value] of Object.entries(data2)) {
      if (key === "import" && typeof value === "string") {
        const importPath = path4.resolve(baseDir, value);
        const importedData = await this.loadImportedFile(importPath);
        Object.assign(resolved, importedData);
      } else if (key === "imports" && Array.isArray(value)) {
        for (const imp of value) {
          if (typeof imp === "string") {
            const importPath = path4.resolve(baseDir, imp);
            const importedData = await this.loadImportedFile(importPath);
            Object.assign(resolved, importedData);
          } else if (imp && typeof imp === "object") {
            const source = imp.import || imp.source;
            if (source) {
              const importPath = path4.resolve(baseDir, source);
              const importedData = await this.loadImportedFile(importPath);
              if (imp.alias) {
                resolved[imp.alias] = importedData;
              } else {
                Object.assign(resolved, importedData);
              }
            }
          }
        }
      }
    }
    for (const [key, value] of Object.entries(data2)) {
      if (key !== "import" && key !== "imports") {
        resolved[key] = await resolveImportsInData.call(this, value, baseDir);
      }
    }
    return resolved;
  }
}

// src/ImportResolver/processImportChain.ts
import path5 from "path";
async function processImportChain(filePath) {
  this.context.importChain = [];
  this.context.loadedFiles.clear();
  this.context.baseDir = path5.dirname(filePath);
  return await this.loadImportedFile(filePath);
}

// src/ImportResolver/index.ts
var ImportResolver = class {
  context;
  constructor() {
    this.context = {
      loadedFiles: /* @__PURE__ */ new Map(),
      importChain: [],
      baseDir: process.cwd()
    };
  }
  async resolveImport(importConfig, baseDir) {
    return resolveImport.call(this, importConfig, baseDir);
  }
  parseImports(content, format) {
    return parseImports.call(this, content, format);
  }
  async loadImportedFile(filePath) {
    return loadImportedFile.call(this, filePath);
  }
  async processImportChain(filePath) {
    return processImportChain.call(this, filePath);
  }
  selectFromData(data2, selector) {
    const keys = selector.split(".");
    let current = data2;
    for (const key of keys) {
      if (current == null || typeof current !== "object") {
        return void 0;
      }
      current = current[key];
    }
    return current;
  }
};

// src/BuildPipeline/loadSources.ts
async function loadSources() {
  if (!this.config.options?.silent) {
    console.log("\u{1F4C1} Loading sources...");
  }
  const importResolver = new ImportResolver();
  for (const [name, sourceConfig] of Object.entries(this.config.sources)) {
    const config2 = sourceConfig;
    const patterns = Array.isArray(config2.pattern) ? config2.pattern : [config2.pattern];
    const files = [];
    const baseDir = this.config.options?.baseDir || process.cwd();
    for (const pattern of patterns) {
      let matches = [];
      if (pattern.match(/^\/.*\/[gimuy]*$/)) {
        matches = await this.resolveRegexPattern(pattern, baseDir);
      } else {
        const globOptions = {
          ignore: config2.exclude || ["**/node_modules/**", "**/dist/**"],
          absolute: true
        };
        const fullPattern = path6.isAbsolute(pattern) ? pattern : path6.join(baseDir, pattern);
        matches = await glob(fullPattern, globOptions);
      }
      files.push(...matches);
    }
    const sourceData = [];
    for (const file of files) {
      const fullPath = path6.isAbsolute(file) ? file : path6.resolve(baseDir, file);
      const relativePath = path6.relative(baseDir, fullPath);
      let parsed;
      try {
        parsed = await importResolver.processImportChain(fullPath);
        switch (config2.parser) {
          case "yaml":
            if (typeof parsed === "string") {
              parsed = yaml4.load(parsed);
            }
            break;
          case "json":
            if (typeof parsed === "string") {
              parsed = JSON.parse(parsed);
            }
            break;
          case "markdown":
            if (!parsed.content && typeof parsed === "string") {
              parsed = { content: parsed, type: "markdown" };
            }
            break;
          default:
        }
        if (config2.transform) {
          parsed = config2.transform(parsed, {
            path: relativePath,
            name: path6.basename(relativePath, path6.extname(relativePath))
          });
        }
        parsed._meta = {
          file: relativePath,
          fullPath,
          source: name,
          lastModified: (await fs4.stat(fullPath)).mtime
        };
        sourceData.push(parsed);
        this.context.files.set(relativePath, {
          path: relativePath,
          fullPath,
          source: name,
          data: parsed
        });
      } catch (error) {
        console.warn(`    Failed to load ${relativePath}:`, error);
        continue;
      }
    }
    this.context.sources[name] = sourceData.length === 1 ? sourceData[0] : sourceData;
  }
}

// src/BuildPipeline/processOutputs.ts
import { promises as fs5 } from "fs";
import path7 from "path";
async function processOutputs() {
  const outputs = /* @__PURE__ */ new Map();
  for (const outputConfig of this.config.outputs) {
    let result;
    if (outputConfig.template) {
      const templatePath = path7.resolve(this.config.options?.baseDir || process.cwd(), outputConfig.template);
      const templateContent = await fs5.readFile(templatePath, "utf-8");
      let templateContext = this.context;
      if (outputConfig.data) {
        templateContext = this.context.sources[outputConfig.data] || this.context;
      }
      result = await this.renderTemplate(templateContent, templateContext);
    } else if (outputConfig.processor) {
      const processor2 = this.processors.get(outputConfig.processor);
      if (!processor2) {
        throw new Error(`Processor '${outputConfig.processor}' not found for output`);
      }
      const input = this.context;
      result = await processor2.process(input, outputConfig.options || {}, this.context);
    } else {
      throw new Error("Output must specify either a template or a processor");
    }
    const dataForTargets = typeof outputConfig.target === "object" && outputConfig.target.forEach ? this.context : result;
    const targets = await this.resolveOutputTargets(outputConfig.target, dataForTargets);
    for (const target of targets) {
      const targetPath = path7.resolve(this.config.options?.baseDir || process.cwd(), target.path);
      await fs5.mkdir(path7.dirname(targetPath), { recursive: true });
      let content;
      if (target.context && outputConfig.template) {
        const templatePath = path7.resolve(this.config.options?.baseDir || process.cwd(), outputConfig.template);
        const templateContent = await fs5.readFile(templatePath, "utf-8");
        content = await this.renderTemplate(templateContent, target.context);
      } else {
        content = target.content || (typeof result === "string" ? result : JSON.stringify(result, null, 2));
      }
      const finalContent = await this.formatOutput(content, outputConfig.format, target.options);
      await fs5.writeFile(targetPath, finalContent, "utf-8");
      const outputKey = path7.basename(target.path);
      outputs.set(outputKey, finalContent);
      if (!this.config.options?.silent) {
        console.log(`\u2705 Generated: ${targetPath}`);
      }
    }
  }
  return outputs;
}

// src/BuildPipeline/resolveInput.ts
function resolveInput(input) {
  if (Array.isArray(input)) {
    const result = {};
    for (const inputKey of input) {
      const resolved = this.resolveInput(inputKey);
      Object.assign(result, resolved);
    }
    return result;
  }
  const parts = input.split(".");
  let current = this.context;
  for (const part of parts) {
    if (current && typeof current === "object" && part in current) {
      current = current[part];
    } else {
      return {};
    }
  }
  return current;
}

// src/BuildPipeline/resolveRegexPattern.ts
import { promises as fs6 } from "fs";
import path8 from "path";
async function resolveRegexPattern(pattern, baseDir) {
  let regex;
  if (pattern instanceof RegExp) {
    regex = pattern;
  } else {
    const regexMatch = pattern.match(/^\/(.+)\/([gimuy]*)$/);
    if (!regexMatch) {
      throw new Error(`Invalid regex pattern: ${pattern}`);
    }
    const [, regexStr, flags] = regexMatch;
    regex = new RegExp(regexStr, flags);
  }
  const matches = [];
  async function walkDir2(dir, relativeTo) {
    try {
      const entries = await fs6.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path8.join(dir, entry.name);
        const relativePath = path8.relative(relativeTo, fullPath);
        if (entry.isDirectory()) {
          if (!["node_modules", "tmp", "dist", ".git"].includes(entry.name)) {
            await walkDir2(fullPath, relativeTo);
          }
        } else if (entry.isFile()) {
          if (regex.test(relativePath) || regex.test(entry.name)) {
            matches.push(relativePath);
          }
        }
      }
    } catch (error) {
    }
  }
  await walkDir2(baseDir, baseDir);
  return matches;
}

// src/BuildPipeline/resolveOutputTargets.ts
async function resolveOutputTargets(target, result) {
  if (typeof target === "string") {
    return [{ path: target }];
  }
  if (Array.isArray(target) && target.every((t) => typeof t === "string")) {
    return target.map((t) => ({ path: t }));
  }
  if (typeof target === "object" && !Array.isArray(target)) {
    return await this.resolveComplexTarget(target, result);
  }
  if (Array.isArray(target)) {
    const resolved = [];
    for (const t of target) {
      if (typeof t === "string") {
        resolved.push({ path: t });
      } else if (typeof t === "object") {
        const complexResolved = await this.resolveComplexTarget(t, result);
        resolved.push(...complexResolved);
      }
    }
    return resolved;
  }
  throw new Error(`Invalid target configuration: ${JSON.stringify(target)}`);
}

// src/BuildPipeline/parseContentSafely.ts
function parseContentSafely(content) {
  try {
    return typeof content === "string" ? JSON.parse(content) : content;
  } catch (error) {
    return content;
  }
}

// src/BuildPipeline/formatAsJson.ts
async function formatAsJson(content, options = {}) {
  try {
    const data2 = parseContentSafely(content);
    return JSON.stringify(data2, null, options.indent || 2);
  } catch (error) {
    return JSON.stringify({ content }, null, options.indent || 2);
  }
}

// src/BuildPipeline/formatAsYaml.ts
async function formatAsYaml(content, options) {
  const yaml7 = __require("js-yaml");
  try {
    const data2 = parseContentSafely(content);
    return yaml7.dump(data2, {
      indent: options.indent || 2,
      lineWidth: options.lineWidth || -1,
      sortKeys: options.sortKeys || false
    });
  } catch (error) {
    return yaml7.dump({ content }, {
      indent: options.indent || 2,
      lineWidth: options.lineWidth || -1
    });
  }
}

// src/BuildPipeline/generateTableOfContents.ts
async function generateTableOfContents(content) {
  const headings = content.match(/^#{1,6}\s+.+$/gm) || [];
  if (headings.length === 0) return "";
  let toc = "## Table of Contents\n\n";
  for (const heading of headings) {
    const level = heading.match(/^#+/)?.[0].length || 1;
    const text = heading.replace(/^#+\s+/, "");
    const anchor = text.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]/g, "");
    const indent = "  ".repeat(Math.max(0, level - 1));
    toc += `${indent}- [${text}](#${anchor})
`;
  }
  return toc;
}

// src/BuildPipeline/formatAsMarkdown.ts
var yaml5 = __require("js-yaml");
async function formatAsMarkdown(content, options = {}) {
  let output = content;
  if (options.frontmatter) {
    const frontmatterYaml = yaml5.dump(options.frontmatter);
    output = `---
${frontmatterYaml}---

${output}`;
  }
  if (options.title) {
    const titleLevel = "#".repeat(options.titleLevel || 1);
    output = `${titleLevel} ${options.title}

${output}`;
  }
  if (options.toc) {
    const toc = await generateTableOfContents.call(this, output);
    output = `${toc}

${output}`;
  }
  return output;
}

// src/BuildPipeline/formatAsHtml.ts
async function formatAsHtml(content, options = {}) {
  const title = options.title || "Generated Document";
  const charset = options.charset || "UTF-8";
  const lang = options.lang || "en";
  let html = content;
  if (options.convertMarkdown && content.includes("#")) {
    html = await this.convertMarkdownToHtml(content);
  }
  if (options.fullDocument !== false) {
    html = `<!DOCTYPE html>
<html lang="${lang}">
<head>
    <meta charset="${charset}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    ${options.css ? `<style>${options.css}</style>` : ""}
    ${options.styles ? options.styles.map((s) => `<link rel="stylesheet" href="${s}">`).join("\n    ") : ""}
</head>
<body>
    ${html}
    ${options.scripts ? options.scripts.map((s) => `<script src="${s}"></script>`).join("\n    ") : ""}
</body>
</html>`;
  }
  return html;
}

// src/BuildPipeline/formatAsXml.ts
async function formatAsXml(content, options = {}) {
  const rootElement = options.rootElement || "root";
  const encoding = options.encoding || "UTF-8";
  let xml = `<?xml version="1.0" encoding="${encoding}"?>
`;
  try {
    const data2 = parseContentSafely(content);
    xml += await this.objectToXml(data2, rootElement);
  } catch (error) {
    xml += `<${rootElement}><![CDATA[${content}]]></${rootElement}>`;
  }
  return xml;
}

// src/BuildPipeline/formatAsCsv.ts
async function formatAsCsv(content, options = {}) {
  try {
    const data2 = parseContentSafely(content);
    if (!Array.isArray(data2)) {
      throw new Error("CSV format requires array data");
    }
    const separator = options.separator || options.delimiter || ",";
    const quote = options.quote || '"';
    const headers = options.headers || (data2.length > 0 ? Object.keys(data2[0]) : []);
    let csv = "";
    if (options.includeHeaders !== false && headers.length > 0) {
      csv += headers.map((h) => `${quote}${h}${quote}`).join(separator) + "\n";
    }
    for (const row of data2) {
      const values = headers.map((header) => {
        const value = row[header] || "";
        return `${quote}${String(value).replace(new RegExp(quote, "g"), quote + quote)}${quote}`;
      });
      csv += values.join(separator) + "\n";
    }
    return csv;
  } catch (error) {
    throw new Error(`Failed to format as CSV: ${error}`);
  }
}

// src/BuildPipeline/formatOutput.ts
async function formatOutput(content, format, options = {}) {
  switch (format) {
    case "json":
      return await formatAsJson.call(this, content, options);
    case "yaml":
    case "yml":
      return await formatAsYaml.call(this, content, options);
    case "markdown":
    case "md":
      return await formatAsMarkdown.call(this, content, options);
    case "html":
      return await formatAsHtml.call(this, content, options);
    case "xml":
      return await formatAsXml.call(this, content, options);
    case "csv":
      return await formatAsCsv.call(this, content, options);
    case "text":
    case "txt":
      return content;
    default:
      const processor2 = this.processors.get(`${format}-formatter`);
      if (processor2) {
        return await processor2.process(content, options, this.context);
      }
      return content;
  }
}

// src/BuildPipeline/objectToXml.ts
async function objectToXml(obj, rootElement) {
  const toXml = (data2, element) => {
    if (typeof data2 === "object" && data2 !== null) {
      if (Array.isArray(data2)) {
        return data2.map((item) => toXml(item, element)).join("");
      } else {
        const elements = Object.entries(data2).map(([key, value]) => toXml(value, key)).join("");
        return `<${element}>${elements}</${element}>`;
      }
    } else {
      return `<${element}>${String(data2)}</${element}>`;
    }
  };
  return toXml(obj, rootElement);
}

// src/BuildPipeline/resolveComplexTarget.ts
async function resolveComplexTarget(targetConfig, result) {
  if (targetConfig.pattern && targetConfig.forEach) {
    return await this.generateDynamicTargets(targetConfig, result);
  }
  if (targetConfig.condition && targetConfig.target) {
    const shouldGenerate = await this.evaluateCondition(targetConfig.condition, result);
    if (shouldGenerate) {
      return await this.resolveOutputTargets(targetConfig.target, result);
    } else {
      return [];
    }
  }
  if (targetConfig.template) {
    const targetPath = await this.renderTemplate(targetConfig.template, result);
    return [{
      path: targetPath,
      content: targetConfig.content,
      options: targetConfig.options
    }];
  }
  if (targetConfig.path) {
    return [{
      path: targetConfig.path,
      content: targetConfig.content,
      options: targetConfig.options
    }];
  }
  throw new Error(`Invalid complex target configuration: ${JSON.stringify(targetConfig)}`);
}

// src/BuildPipeline/generateDynamicTargets.ts
async function generateDynamicTargets(targetConfig, result) {
  const targets = [];
  const data2 = this.getDataForPattern(targetConfig.forEach, result);
  if (Array.isArray(data2)) {
    for (let i = 0; i < data2.length; i++) {
      const item = data2[i];
      const context = { item, index: i, data: data2, ...item };
      const targetPath = await this.renderTemplate(targetConfig.pattern, context);
      const content = targetConfig.contentTemplate ? await this.renderTemplate(targetConfig.contentTemplate, context) : void 0;
      targets.push({
        path: targetPath,
        content,
        options: targetConfig.options,
        context
        // Pass context for template rendering
      });
    }
  } else if (typeof data2 === "object") {
    for (const [key, value] of Object.entries(data2)) {
      const context = { key, value, data: data2 };
      const targetPath = await this.renderTemplate(targetConfig.pattern, context);
      const content = targetConfig.contentTemplate ? await this.renderTemplate(targetConfig.contentTemplate, context) : void 0;
      targets.push({
        path: targetPath,
        content,
        options: targetConfig.options
      });
    }
  }
  return targets;
}

// src/BuildPipeline/getDataForPattern.ts
function getDataForPattern(pattern, result) {
  if (pattern === "." || pattern === "") {
    return result;
  }
  const keys = pattern.split(".");
  let current = result;
  for (const key of keys) {
    if (key === "") continue;
    if (current == null) return void 0;
    current = current[key];
  }
  return current;
}

// src/BuildPipeline/evaluateCondition.ts
async function evaluateCondition(condition, result) {
  if (typeof condition === "function") {
    return await condition(result);
  }
  if (typeof condition === "string") {
    const keys = condition.split(".");
    let current = result;
    for (const key of keys) {
      if (current == null) return false;
      current = current[key];
    }
    if (Array.isArray(current) && current.length === 0) return false;
    if (current === 0 || current === "" || current === false) return false;
    return !!current;
  }
  return false;
}

// src/BuildPipeline/convertMarkdownToHtml.ts
async function convertMarkdownToHtml(markdown) {
  return markdown.replace(/^### (.+)$/gm, "<h3>$1</h3>").replace(/^## (.+)$/gm, "<h2>$1</h2>").replace(/^# (.+)$/gm, "<h1>$1</h1>").replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>").replace(/\*(.+?)\*/g, "<em>$1</em>").replace(/`(.+?)`/g, "<code>$1</code>").replace(/\n\n/g, "</p><p>").replace(/^(.+)$/gm, "<p>$1</p>");
}

// src/BuildPipeline/renderTemplate.ts
async function renderTemplate(template, context) {
  const flatContext = { ...context };
  if (context.sources) {
    for (const [key, value] of Object.entries(context.sources)) {
      if (Array.isArray(value) && value.length === 1) {
        flatContext[key] = value[0];
      } else {
        flatContext[key] = value;
      }
    }
  }
  const templateInstance = new Template(template, flatContext);
  return templateInstance.render();
}

// src/BuildPipeline/walkDir.ts
async function walkDir(dirPath, callback) {
  const fs9 = __require("fs").promises;
  const path12 = __require("path");
  try {
    const entries = await fs9.readdir(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path12.join(dirPath, entry.name);
      if (entry.isDirectory()) {
        await this.walkDir(fullPath, callback);
      } else {
        callback(fullPath);
      }
    }
  } catch (error) {
  }
}

// src/BuildPipeline/index.ts
var BuildPipeline = class {
  config;
  context;
  processors;
  constructor(config2) {
    constructor2.call(this, config2);
  }
  async execute() {
    return execute.call(this);
  }
  async executeTask(task) {
    return executeTask.call(this, task);
  }
  async loadSources() {
    return loadSources.call(this);
  }
  async processOutputs() {
    return processOutputs.call(this);
  }
  resolveInput(input) {
    return resolveInput.call(this, input);
  }
  async resolveRegexPattern(pattern, baseDir) {
    return resolveRegexPattern.call(this, pattern, baseDir);
  }
  async resolveOutputTargets(target, result) {
    return resolveOutputTargets.call(this, target, result);
  }
  async formatOutput(content, format, options = {}) {
    return formatOutput.call(this, content, format, options);
  }
  registerProcessor(processor2) {
    this.processors.set(processor2.name, processor2);
  }
  // Format helper methods - all delegated
  async formatAsMarkdown(content, options) {
    return formatAsMarkdown.call(this, content, options);
  }
  async formatAsHtml(content, options = {}) {
    return formatAsHtml.call(this, content, options);
  }
  async formatAsJson(content, options = {}) {
    return formatAsJson.call(this, content, options);
  }
  async formatAsYaml(content, options) {
    return formatAsYaml.call(this, content, options);
  }
  async formatAsXml(content, options = {}) {
    return formatAsXml.call(this, content, options);
  }
  async formatAsCsv(content, options = {}) {
    return formatAsCsv.call(this, content, options);
  }
  async objectToXml(obj, rootElement) {
    return objectToXml.call(this, obj, rootElement);
  }
  // Complex target resolution methods - all delegated
  async resolveComplexTarget(targetConfig, result) {
    return resolveComplexTarget.call(this, targetConfig, result);
  }
  async generateDynamicTargets(targetConfig, result) {
    return generateDynamicTargets.call(this, targetConfig, result);
  }
  getDataForPattern(pattern, result) {
    return getDataForPattern.call(this, pattern, result);
  }
  async evaluateCondition(condition, result) {
    return evaluateCondition.call(this, condition, result);
  }
  async convertMarkdownToHtml(markdown) {
    return convertMarkdownToHtml.call(this, markdown);
  }
  async renderTemplate(template, context) {
    return renderTemplate.call(this, template, context);
  }
  async walkDir(dirPath, callback) {
    return walkDir.call(this, dirPath, callback);
  }
};

// src/ConfigLoader/constructor.ts
function constructor3(configPath) {
  this.configPath = configPath;
  this.config = void 0;
}

// src/ConfigLoader/loadConfig.ts
import { promises as fs7 } from "fs";
import path9 from "path";
import yaml6 from "js-yaml";
async function loadConfig(configPath) {
  const targetPath = configPath || this.configPath;
  if (this.config && !configPath) {
    return this.config;
  }
  let config2 = {};
  if (targetPath) {
    const exists = await fs7.access(targetPath).then(() => true).catch(() => false);
    if (!exists) {
      if (!configPath && !this.configPath) {
        config2 = {};
      } else {
        throw new Error(`Config file not found: ${targetPath}`);
      }
    } else {
      const ext = path9.extname(targetPath).toLowerCase();
      const content = await fs7.readFile(targetPath, "utf-8");
      switch (ext) {
        case ".js":
        case ".mjs":
          try {
            const module = await import(path9.resolve(targetPath));
            config2 = module.default || module;
          } catch (err) {
            try {
              delete __require.cache[path9.resolve(targetPath)];
              const requireResult = __require(path9.resolve(targetPath));
              if (requireResult && typeof requireResult === "object" && "default" in requireResult) {
                config2 = requireResult.default;
              } else {
                config2 = requireResult;
              }
            } catch (requireErr) {
              throw new Error(`Failed to load config file: ${targetPath}
${err.message}`);
            }
          }
          break;
        case ".json":
          config2 = JSON.parse(content);
          break;
        case ".yaml":
        case ".yml":
          config2 = yaml6.load(content);
          break;
        default:
          throw new Error(`Unsupported config file format: ${ext}`);
      }
    }
  }
  this.config = this.resolveConfig(config2);
  this.validateConfig(this.config);
  return this.config;
}

// src/ConfigLoader/resolveConfig.ts
import path10 from "path";
function resolveConfig(config2, baseDir) {
  const resolveDir = baseDir || process.cwd();
  return {
    sources: config2.sources || {
      particles: {
        pattern: "particles/**/*.{yaml,yml}",
        parser: "yaml"
      },
      components: {
        pattern: "components/**/*.{yaml,yml}",
        parser: "yaml"
      },
      documents: {
        pattern: "documents/**/*.{yaml,yml}",
        parser: "yaml"
      }
    },
    build: {
      tasks: config2.build?.tasks || [
        {
          name: "load-particles",
          input: "particles",
          processor: "particle-loader"
        },
        {
          name: "load-components",
          input: "components",
          processor: "component-loader"
        },
        {
          name: "compose-documents",
          input: ["particles", "components", "documents"],
          processor: "document-composer"
        }
      ],
      parallel: config2.build?.parallel ?? false,
      bail: config2.build?.bail ?? true
    },
    outputs: config2.outputs || [
      {
        target: "output/**/*.md",
        format: "markdown",
        processor: "markdown-renderer"
      }
    ],
    plugins: config2.plugins || [],
    watch: config2.watch || {
      patterns: ["particles/**/*", "components/**/*", "documents/**/*"],
      ignore: ["node_modules/**", "output/**"],
      debounce: 1e3
    },
    options: {
      ...config2.options,
      baseDir: config2.options?.baseDir ? path10.isAbsolute(config2.options.baseDir) ? config2.options.baseDir : path10.resolve(resolveDir, config2.options.baseDir) : resolveDir,
      cacheDir: config2.options?.cacheDir || "tmp",
      verbose: config2.options?.verbose || false
    }
  };
}

// src/ConfigLoader/validateConfig.ts
function validateConfig(config2) {
  if (!config2.sources) {
    throw new Error("Config must have sources");
  }
  if (typeof config2.sources !== "object" || Array.isArray(config2.sources)) {
    throw new Error("Config sources must be an object");
  }
  for (const [name, source] of Object.entries(config2.sources)) {
    if (!source.pattern) {
      throw new Error(`Source '${name}' must define a pattern`);
    }
  }
  if (!config2.build) {
    throw new Error("Config must have build");
  }
  if (typeof config2.build !== "object" || Array.isArray(config2.build)) {
    throw new Error("Config build must be an object");
  }
  if (!Array.isArray(config2.build.tasks)) {
    throw new Error("Config build.tasks must be an array");
  }
  for (const task of config2.build.tasks) {
    if (!task.name) {
      throw new Error("Each task must have a name");
    }
    if (!task.input) {
      throw new Error(`Task '${task.name}' must define input`);
    }
    if (!task.processor) {
      throw new Error(`Task '${task.name}' must define a processor`);
    }
  }
  if (!config2.outputs) {
    throw new Error("Config must have outputs");
  }
  if (!Array.isArray(config2.outputs)) {
    throw new Error("Config outputs must be an array");
  }
  for (const output of config2.outputs) {
    if (!output.target) {
      throw new Error("Each output must define a target");
    }
    if (!output.processor && !output.template) {
      throw new Error("Each output must define either a processor or a template");
    }
  }
}

// src/ConfigLoader/index.ts
var ConfigLoader = class {
  configPath;
  config;
  constructor(configPath) {
    constructor3.call(this, configPath);
  }
  async loadConfig(configPath) {
    return loadConfig.call(this, configPath);
  }
  resolveConfig(config2, baseDir) {
    return resolveConfig.call(this, config2, baseDir);
  }
  validateConfig(config2) {
    return validateConfig.call(this, config2);
  }
  findConfigFile() {
    const candidates = [
      "composer.config.js",
      "composer.config.mjs",
      "composer.config.yaml",
      "composer.config.yml",
      "composer.config.json"
    ];
    return candidates[0];
  }
};

// src/Composer/render/with/config.ts
async function config(configPath) {
  const loader = new ConfigLoader(configPath);
  const config2 = await loader.loadConfig();
  const pipeline = new BuildPipeline(config2);
  if (this.customProcessors) {
    for (const processor2 of this.customProcessors) {
      pipeline.registerProcessor(processor2);
    }
  }
  return await pipeline.execute();
}

// src/Composer/register/processor.ts
function processor(processorDef) {
  if (!this.customProcessors) {
    this.customProcessors = [];
  }
  this.customProcessors.push(processorDef);
  if (this.options.verbose) {
    console.log(`\u{1F4E6} Registered custom processor: ${processorDef.name}`);
  }
}

// src/Composer/watch.ts
import chokidar from "chokidar";
function watch(callback) {
  if (this.watcher) {
    this.stop();
  }
  const paths = [
    this.options.dataPath,
    this.options.templatesPath,
    this.options.particlesPath,
    this.options.componentsPath,
    this.options.documentsPath
  ].filter((p) => p);
  let debounceTimer = null;
  let isProcessing = false;
  const handleChange = async (filepath, event = "change") => {
    console.log(`File changed: ${filepath}`);
    if (debounceTimer) {
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }
    if (isProcessing) {
      debounceTimer = setTimeout(() => handleChange(filepath, event), this.options.debounceMs || 100);
      return;
    }
    debounceTimer = setTimeout(async () => {
      if (isProcessing) return;
      isProcessing = true;
      try {
        const outputs = await this.render();
        if (callback) {
          callback(outputs);
        }
      } catch (error) {
        console.error("Error during rebuild:", error);
      } finally {
        isProcessing = false;
        debounceTimer = null;
      }
    }, this.options.debounceMs || 100);
  };
  this.watcher = chokidar.watch(paths, {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 100,
      // Reduced for faster response
      pollInterval: 50
      // More frequent polling
    },
    usePolling: false,
    // Use native events when possible
    atomic: true,
    // Handle atomic file operations better
    alwaysStat: true,
    // Get file stats for better reliability
    followSymlinks: false,
    // Don't follow symlinks to prevent loops
    interval: 100,
    // Polling fallback interval
    binaryInterval: 300
    // Binary file polling interval
  });
  this.watcher.on("add", (filepath) => handleChange(filepath, "add")).on("change", (filepath) => handleChange(filepath, "change")).on("unlink", (filepath) => handleChange(filepath, "unlink")).on("error", (error) => {
    console.error("Watch error:", error);
    if (this.watcher) {
      try {
        this.watcher.close();
      } catch (e) {
        console.error("Error closing watcher after error:", e);
      }
      this.watcher = null;
    }
  }).on("ready", () => {
    console.log(`Watcher ready. Watching for changes in: ${paths.join(", ")}`);
  });
  console.log(`Watching for changes in: ${paths.join(", ")}`);
}

// src/Composer/stop.ts
function stop() {
  if (this.watcher) {
    try {
      this.watcher.close().then(() => {
        console.log("Stopped watching for changes");
      }).catch((error) => {
        console.error("Error stopping watcher:", error);
      });
    } catch (error) {
      console.error("Error during watcher cleanup:", error);
    } finally {
      this.watcher = null;
    }
  }
}

// src/Composer/index.ts
var Composer = class {
  options;
  context;
  watcher = null;
  customProcessors;
  constructor(options = {}) {
    constructor.call(this, options);
  }
  async loadData() {
    return data.call(this);
  }
  async render() {
    return render2.call(this);
  }
  async renderWithConfig(configPath) {
    return config.call(this, configPath);
  }
  registerProcessor(processor2) {
    return processor.call(this, processor2);
  }
  watch(callback) {
    return watch.call(this, callback);
  }
  stop() {
    return stop.call(this);
  }
};

// src/Platform/Node/index.ts
import os from "os";
import path11 from "path";
import { promises as fs8 } from "fs";
import { execSync } from "child_process";
var NodeStrategy = class {
  getName() {
    return `Node.js ${process.version} on ${os.platform()}`;
  }
  getCapabilities() {
    return {
      platform: process.platform,
      runtime: "node",
      // Runtime detection
      hasBun: this.hasCommand("bun"),
      hasNode: true,
      hasDeno: this.hasCommand("deno"),
      // File system
      hasSymlinks: process.platform !== "win32",
      hasHardlinks: process.platform !== "win32",
      caseSensitiveFS: process.platform !== "win32" && process.platform !== "darwin",
      // Performance
      hasNativeWatch: true,
      hasFastGlob: this.hasPackage("fast-glob"),
      // Permissions
      isRoot: process.getuid ? process.getuid() === 0 : false,
      canSudo: this.hasCommand("sudo"),
      hasShell: this.hasShell(),
      // Architecture
      arch: process.arch,
      // Package managers
      hasNpm: this.hasCommand("npm"),
      hasPnpm: this.hasCommand("pnpm"),
      hasYarn: this.hasCommand("yarn")
    };
  }
  getPaths() {
    const home = os.homedir();
    return {
      home,
      // Data directories
      userData: this.getUserDataDir(),
      appData: this.getAppDataDir(),
      documents: path11.join(home, "Documents"),
      downloads: path11.join(home, "Downloads"),
      desktop: path11.join(home, "Desktop"),
      // Config directories
      config: this.getConfigDir(),
      cache: this.getCacheDir(),
      temp: os.tmpdir(),
      logs: this.getLogsDir(),
      // System paths
      system: this.getSystemDir(),
      bin: this.getBinDir(),
      lib: this.getLibDir(),
      // Separators
      sep: path11.sep,
      delimiter: path11.delimiter
    };
  }
  normalizePath(filePath) {
    return path11.normalize(filePath);
  }
  isAbsolutePath(filePath) {
    return path11.isAbsolute(filePath);
  }
  async createDirectory(dirPath) {
    await fs8.mkdir(dirPath, {
      recursive: true,
      mode: process.platform === "win32" ? void 0 : 493
    });
  }
  resolveDataDir(appName) {
    const base = this.getUserDataDir();
    return path11.join(base, appName);
  }
  resolveConfigDir(appName) {
    const base = this.getConfigDir();
    return path11.join(base, appName);
  }
  resolveCacheDir(appName) {
    const base = this.getCacheDir();
    return path11.join(base, appName);
  }
  resolveTempDir(appName) {
    return path11.join(os.tmpdir(), appName);
  }
  getEnvVars() {
    return { ...process.env };
  }
  async executeCommand(command) {
    try {
      return execSync(command, {
        encoding: "utf-8",
        timeout: 3e4
      });
    } catch (error) {
      throw new Error(`Command failed: ${command}
${error.message}`);
    }
  }
  getWatcherType() {
    return this.hasPackage("chokidar") ? "chokidar" : "fs.watch";
  }
  getGlobType() {
    return this.hasPackage("fast-glob") ? "fast-glob" : "glob";
  }
  // Protected helper methods  
  hasCommand(cmd) {
    try {
      execSync(`which ${cmd}`, { stdio: "ignore" });
      return true;
    } catch {
      return false;
    }
  }
  hasPackage(pkg) {
    try {
      __require.resolve(pkg);
      return true;
    } catch {
      return false;
    }
  }
  hasShell() {
    return Boolean(process.env.SHELL || process.env.ComSpec);
  }
  getUserDataDir() {
    switch (process.platform) {
      case "win32":
        return process.env.APPDATA || path11.join(os.homedir(), "AppData", "Roaming");
      case "darwin":
        return path11.join(os.homedir(), "Library", "Application Support");
      default:
        return process.env.XDG_DATA_HOME || path11.join(os.homedir(), ".local", "share");
    }
  }
  getAppDataDir() {
    return this.getUserDataDir();
  }
  getConfigDir() {
    switch (process.platform) {
      case "win32":
        return process.env.APPDATA || path11.join(os.homedir(), "AppData", "Roaming");
      case "darwin":
        return path11.join(os.homedir(), "Library", "Preferences");
      default:
        return process.env.XDG_CONFIG_HOME || path11.join(os.homedir(), ".config");
    }
  }
  getCacheDir() {
    switch (process.platform) {
      case "win32":
        return process.env.LOCALAPPDATA || path11.join(os.homedir(), "AppData", "Local");
      case "darwin":
        return path11.join(os.homedir(), "Library", "Caches");
      default:
        return process.env.XDG_CACHE_HOME || path11.join(os.homedir(), ".cache");
    }
  }
  getLogsDir() {
    switch (process.platform) {
      case "win32":
        return path11.join(this.getUserDataDir(), "logs");
      case "darwin":
        return path11.join(os.homedir(), "Library", "Logs");
      default:
        return path11.join(this.getUserDataDir(), "logs");
    }
  }
  getSystemDir() {
    switch (process.platform) {
      case "win32":
        return process.env.SYSTEMROOT || "C:\\Windows";
      default:
        return "/usr";
    }
  }
  getBinDir() {
    switch (process.platform) {
      case "win32":
        return "C:\\Windows\\System32";
      default:
        return "/usr/bin";
    }
  }
  getLibDir() {
    switch (process.platform) {
      case "win32":
        return "C:\\Windows\\System32";
      default:
        return "/usr/lib";
    }
  }
};

// src/Platform/Bun/index.ts
var BunStrategy = class extends NodeStrategy {
  getName() {
    const bunVersion = globalThis.Bun?.version || "unknown";
    return `Bun ${bunVersion} on ${process.platform}`;
  }
  getCapabilities() {
    const base = super.getCapabilities();
    return {
      ...base,
      runtime: "bun",
      hasBun: true,
      // Bun has optimized file operations
      hasNativeWatch: true,
      hasFastGlob: true
      // Bun has built-in fast glob
    };
  }
  async executeCommand(command) {
    try {
      const Bun = globalThis.Bun;
      if (Bun?.spawn) {
        const proc = Bun.spawn({
          cmd: command.split(" "),
          stdout: "pipe",
          stderr: "pipe"
        });
        const output = await new Response(proc.stdout).text();
        const exitCode = await proc.exited;
        if (exitCode !== 0) {
          const error = await new Response(proc.stderr).text();
          throw new Error(`Command failed with exit code ${exitCode}: ${error}`);
        }
        return output;
      }
    } catch (error) {
      return super.executeCommand(command);
    }
    return super.executeCommand(command);
  }
  getWatcherType() {
    return "fs.watch";
  }
  getGlobType() {
    return "fast-glob";
  }
  async createDirectory(dirPath) {
    try {
      const Bun = globalThis.Bun;
      if (Bun?.file && Bun?.write) {
        await Bun.write(Bun.file(dirPath + "/.keep"), "");
        return;
      }
    } catch {
    }
    return super.createDirectory(dirPath);
  }
};

// src/Platform/Unix/index.ts
var UnixStrategy = class extends NodeStrategy {
  getName() {
    return `Unix (${process.platform}) ${process.arch}`;
  }
  getCapabilities() {
    const base = super.getCapabilities();
    return {
      ...base,
      // Unix has full symlink support
      hasSymlinks: true,
      hasHardlinks: true,
      // Case sensitivity varies
      caseSensitiveFS: process.platform !== "darwin",
      // Unix typically has better file watching
      hasNativeWatch: true,
      // Shell is always available on Unix
      hasShell: true
    };
  }
  async executeCommand(command) {
    const shellCommand = `/bin/sh -c "${command}"`;
    return super.executeCommand(shellCommand);
  }
  getWatcherType() {
    return this.hasPackage("chokidar") ? "chokidar" : "fs.watch";
  }
  resolveTempDir(appName) {
    const tmpDir = process.env.TMPDIR || "/tmp";
    return `${tmpDir}/${appName}`;
  }
};

// src/Platform/Windows/index.ts
var WindowsStrategy = class extends NodeStrategy {
  getName() {
    return `Windows ${process.arch}`;
  }
  getCapabilities() {
    const base = super.getCapabilities();
    return {
      ...base,
      // Windows limitations
      hasSymlinks: false,
      // Usually requires admin
      hasHardlinks: false,
      caseSensitiveFS: false,
      // Windows file watching can be unreliable
      hasNativeWatch: false,
      // Shell handling
      hasShell: Boolean(process.env.ComSpec)
    };
  }
  normalizePath(filePath) {
    return super.normalizePath(filePath).replace(/\//g, "\\");
  }
  async executeCommand(command) {
    const shellCommand = `cmd.exe /c "${command}"`;
    return super.executeCommand(shellCommand);
  }
  getWatcherType() {
    return "polling";
  }
  getGlobType() {
    return this.hasPackage("fast-glob") ? "fast-glob" : "manual";
  }
  resolveTempDir(appName) {
    const tmpDir = process.env.TEMP || process.env.TMP || "C:\\temp";
    return `${tmpDir}\\${appName}`;
  }
  hasCommand(cmd) {
    try {
      const { execSync: execSync2 } = __require("child_process");
      execSync2(`where ${cmd}`, { stdio: "ignore" });
      return true;
    } catch {
      return false;
    }
  }
};

// src/Platform/index.ts
var Platform = class _Platform {
  static instance = null;
  strategy;
  constructor() {
    this.strategy = this.detectAndCreateStrategy();
  }
  /**
   * Singleton pattern - ensures one platform strategy per process
   */
  static getInstance() {
    if (!_Platform.instance) {
      _Platform.instance = new _Platform();
    }
    return _Platform.instance;
  }
  /**
   * Detects runtime and platform, creates appropriate strategy
   */
  detectAndCreateStrategy() {
    if (typeof globalThis !== "undefined" && "Bun" in globalThis) {
      return new BunStrategy();
    }
    const platform = process.platform;
    switch (platform) {
      case "win32":
        return new WindowsStrategy();
      case "linux":
      case "darwin":
      case "freebsd":
      case "openbsd":
      case "sunos":
      case "aix":
        return new UnixStrategy();
      default:
        console.warn(`Unknown platform: ${platform}, using Node.js strategy`);
        return new NodeStrategy();
    }
  }
  /**
   * Get the current platform strategy
   */
  getStrategy() {
    return this.strategy;
  }
  /**
   * Get platform capabilities
   */
  getCapabilities() {
    return this.strategy.getCapabilities();
  }
  /**
   * Get platform-specific paths
   */
  getPaths() {
    return this.strategy.getPaths();
  }
  /**
   * Get platform name
   */
  getName() {
    return this.strategy.getName();
  }
  /**
   * Detect optimal file watching strategy
   */
  getWatcherType() {
    return this.strategy.getWatcherType();
  }
  /**
   * Get optimal glob library
   */
  getGlobType() {
    return this.strategy.getGlobType();
  }
  /**
   * Resolve data directory with platform conventions
   */
  resolveDataDir(appName = "composer") {
    return this.strategy.resolveDataDir(appName);
  }
  /**
   * Resolve config directory with platform conventions
   */
  resolveConfigDir(appName = "composer") {
    return this.strategy.resolveConfigDir(appName);
  }
  /**
   * Resolve cache directory with platform conventions
   */
  resolveCacheDir(appName = "composer") {
    return this.strategy.resolveCacheDir(appName);
  }
  /**
   * Resolve temp directory with platform conventions
   */
  resolveTempDir(appName = "composer") {
    return this.strategy.resolveTempDir(appName);
  }
  /**
   * Get environment variables with platform-specific handling
   */
  getEnvVars() {
    return this.strategy.getEnvVars();
  }
  /**
   * Normalize file paths for platform
   */
  normalizePath(filePath) {
    return this.strategy.normalizePath(filePath);
  }
  /**
   * Check if path is absolute
   */
  isAbsolutePath(filePath) {
    return this.strategy.isAbsolutePath(filePath);
  }
  /**
   * Create directory with platform-appropriate permissions
   */
  async createDirectory(dirPath) {
    return this.strategy.createDirectory(dirPath);
  }
  /**
   * Execute shell command with platform handling
   */
  async executeCommand(command) {
    return this.strategy.executeCommand(command);
  }
  /**
   * Force a specific strategy (useful for testing)
   */
  setStrategy(strategy) {
    this.strategy = strategy;
  }
};
var Platform_default = Platform.getInstance();
export {
  BuildPipeline,
  Composer,
  ConfigLoader,
  ImportResolver,
  Platform,
  Template
};
